{"./":{"url":"./","title":"Introduction","keywords":"","body":"React官方文档翻译 打算把React官方文档翻译一遍，有可能也会加入一点自己的理解。 翻译出来就不用每次都去看一坨英文了，长痛不如短痛，希望能坚持下去啦~ 主要是这三块内容： React快速开始 React高级指南 React官方博客 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 22:23:59 "},"React快速开始/React快速开始（一）安装.html":{"url":"React快速开始/React快速开始（一）安装.html","title":"安装","keywords":"","body":" InstallationOptimizing Performance 安装 react很灵活，可用于各种项目。 可以使用它创建新的应用程序，也可以引入到现有的代码库中。看看下面哪一种方式是你需要的。 如果只想试一试React 如果只想试一试React，那就使用CodePen，不需要安装任何东西，直接写React代码就能看到效果。 可以试一下 Hello World example code 如果使用自己的文本编辑器，可以像下面这样写一个html文件，就可以在本地直接用浏览器打开看到效果。 Hello World ReactDOM.render( Hello, world!, document.getElementById('root') ); 创建React应用程序 看这里 >> create-react-app，这是构建新的React单页应用程序的最佳方法，能够使用JavaScript最新特性 npm install -g create-react-app create-react-app my-app cd my-app npm start 这样创建的应用程序是零配置的，没有使用babel和webpack 在已有项目中引入React 一个经典的React项目应该具备这些： 包管理器 比如Yarn 或者 npm，使用它可以更方便的管理第三方包，并且很方便的安装和更新包 打包工具 比如webpack 或者 Browserify，它可以让你编写模块化代码并将各个模块打包在一起，以优化加载时间。 编译器 如Babel， 可以将新的JavaScript特性编译成适用于旧版浏览器的JavaScript代码。 在项目中安装React yarn init yarn add react react-dom npm install --save react react-dom npm init Yarn 和 npm 都是从npm registry下载包的 开发和生产版本 默认情况下，React包含许多有用的警告，这些警告在开发中非常有用。但是这会让项目更大更慢，所以部署项目到线上时应该使用开发版本。 那么怎样告诉你的网站使用正确的版本，最有效地配置生产构建过程呢？下面介绍了几种项目配置 create-react-app 执行npm run build会在项目的build/目录生成生产版本代码，如果不是在生产环境，执行npm start 引用外部文件 下面引用的直接就是生产环境版本，注意只有 .min.js结尾的才是生产环境稳定版本 Brunch配置 安装插件uglify-js-brunch //If you use npm npm install --save-dev uglify-js-brunch //If you use Yarn yarn add --dev uglify-js-brunch 然后使用brunch build -p构建 Browserify配置 安装几个插件 //If you use npm npm install --save-dev bundle-collapser envify uglify-js uglifyify //If you use Yarn yarn add --dev bundle-collapser envify uglify-js uglifyify 执行时带上这些transforms envify uglifyify bundle-collapser 最后结果都pipe到uglify-js 例如: browserify ./index.js \\ -g [ envify --NODE_ENV production ] \\ -g uglifyify \\ -p bundle-collapser/plugin \\ | uglifyjs --compress --mangle > ./bundle.js Rollup配置 安装插件 //If you use npm npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify //If you use Yarn yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify 再配置文件 plugins: [ // ... require('rollup-plugin-replace')({ 'process.env.NODE_ENV': JSON.stringify('production') }), require('rollup-plugin-commonjs')(), require('rollup-plugin-uglify')(), // ... ] webpack配置 例如, npm run build会根据生产版本配置文件webpack.config.js构建, npm run dev会根据开发配置文件webpack-dev.config.js构建 在生产版本配置文件webpack.config.js中配置如下插件，需要生产版本就执行npm run build，平时开发就执行npm run dev new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production') } }), new webpack.optimize.UglifyJsPlugin() Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 22:55:53 "},"React快速开始/React快速开始（二）使用JSX.html":{"url":"React快速开始/React快速开始（二）使用JSX.html","title":"使用JSX","keywords":"","body":" Introducing JSX 使用JSX JSX，全称 JavaScript XML ，一种类XML语言，它是JavaScript的语法扩展。 没有使用JSX var element = React.createElement( \"h1\", null, \"Hello, world!\" ); 使用JSX const element = Hello, world!; 可以看出使用JSX可以让代码可读性更高、语义更清晰、更易维护。JSX类似于模板引擎，但功能更强大 语法 1、可以在JSX中嵌入任何JavaScript表达式，方法是将其包装在花括号中。 const element = (Hello, {formatName(user)}!); 2、将JSX分割成多行，可读性更好。这不是必需的，但在这样做的时候，建议把它放在括号中，以避免自动分号插入的陷阱。 const element = ( Hello, {formatName(user)}! ); 3、JSX也是一个表达式，编译后，JSX表达式就是常规的JavaScript对象。这意味着可以在if语句和for循环中使用JSX、将其分配给变量、接受它作为参数、并从函数返回它 function getGreeting(user) { if (user) { return Hello, {formatName(user)}!; } return Hello, Stranger.; } 4、用JSX指定属性 引号和花括号不能同时使用 注意: 在JSX中，属性使用驼峰式命名，例如class变为className,font-size变为fontSize //用引号指定字符串作为属性 const element = ; //使用花括号将JavaScript表达式嵌入到属性中 const element = ; 5、用JSX指定children 如果标签为空，则可以使用/>关闭 const element = ; JSX标签也可以有children const element = ( Hello! Good to see you here. ) 6、JSX可以防止脚本注入攻击，在JSX中嵌入用户输入是安全的 默认情况下，React DOM会在渲染之前转义嵌入在JSX中的任何值，确保不会注入任何未明确写入应用程序的内容。 例如： {'First &middot; Second'} 花括号中的内容并不会展示为 First · Second在呈现之前，所有内容都将转换为字符串。 这有助于防止XSS（跨站点脚本）攻击。 const title = response.potentiallyMaliciousInput; // 这样是安全的 const element = {title}; 7、JSX的对象表示Babel将JSX编译成React.createElement（）调用。这两个例子是一样的： const element = ( Hello, world! ); ReactDOM.render(element, document.getElementById(\"root\")); 编译后： const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); ReactDOM.render(element, document.getElementById(\"root\")); React.createElement（）会执行一些检查帮助你编写无错误代码， 它会创建一个基本类似于如下所示的对象： // 注意：这个结构被简化了 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world' } }; 这些对象称为“React元素”, React读取这些对象，并使用它们构造DOM呈现页面最新状态。 另外，使用ReactDOM.render()，React可以嵌入到使用其他JavaScript UI库的应用程序中。 JSX使用经验 使用事件 JSX采用驼峰写法来描述事件名称，例如onChange、onClick 使用样式 样式属性名用-连接的都采用驼峰写法，例如font-size : fontSize,background-color:backgroundColor 静态样式 动态样式 let spanStyle = { color: '#ff6633', fontSize: '14px' }; 使用表达式 {}里面都是表达式，那就可以这样写 render(){ return( { this.state.show ? ( 噢噢噢噢 ) : null } ) } 使用注释 render(){ return( 噢噢噢噢 { //这里是注释 } ) } Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 22:56:27 "},"React快速开始/React快速开始（三）渲染元素.html":{"url":"React快速开始/React快速开始（三）渲染元素.html","title":"渲染元素","keywords":"","body":" Rendering Elements 元素是React应用最小构建块，每一个元素都描述了呈现在屏幕上的内容。不同于真实的DOM元素，React元素就是一个普通的对象，创建成本很低，React DOM负责更新真实DOM与React元素匹配。 关于组件、元素和实例可以看这个 React Components, Elements, and Instances 将元素渲染到DOM中 假设你的HTML文件中有一个,这个节点里面的内容都由 React DOM来管理。 使用React构建的应用程序通常具有单个根DOM节点，要将React元素渲染到根DOM节点中，需要将他们传递给ReactDOM.render() const element = Hello, world; ReactDOM.render( element, document.getElementById('root') ); 更新已渲染元素 React元素是不可变的，创建元素后无法更改其子项或属性,一个元素就像一个电影中的一帧：它代表了某个时间点的UI。 根据我们目前的知识，更新UI的唯一方法是创建一个新元素，并将其传递给ReactDOM.render()。 看下面这个显示时间的例子,每秒钟都会执行一次ReactDOM.render() function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 实际上，大多数React应用只会调用ReactDOM.render()一次,在接下来的章节中，我们会学习如何将这些代码封装到有状态的组件中。 React仅在必要时更新 尽管我们创建了一个描述整个UI树的元素，但只有内容改变的节点才被React DOM更新。因为ReactDOM会将元素及其子元素与之前的元素进行比较，并且只更新实际改变的DOM。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 22:35:45 "},"React快速开始/React快速开始（四）组件和props.html":{"url":"React快速开始/React快速开始（四）组件和props.html","title":"组件和props","keywords":"","body":" Components and Props 使用组件可以将UI拆分成独立的可重复使用的部分，然后可以单独考虑每个组件的渲染。从概念上来讲，组件就像JavaScript函数，接受任意输入（称为“props”），并返回描述页面呈现的React元素。 函数组件和类组件（Functional and Class ） 定义组件最简单的方法是：编写一个JavaScript函数： function Welcome(props) { return Hello, {props.name}; } 这个函数是一个有效的React组件，因为它接受一个单一的“props”对象参数并返回一个React元素。 我们将这样的组件称为“functional组件”，因为它们在字面上是一个JavaScript函数。 还可以使用ES6类来定义组件： class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } 上面这两个组件是等同的，class组件有一些额外的功能（state、钩子函数），这会在下一章节讨论，这里先使用functional组件来讨论 渲染组件 之前我们遇到的元素，都是DOM标签： const element = ; 我们也可以自定义元素，代表一个组件 const element = ; 当React知道这是一个表示用户定义的元素时，它将JSX属性作为单个对象传递给该组件。 我们称这个对象为“props”。例如： Try it on CodePen function Welcome(props) { return Hello, {props.name}; } const element = ; ReactDOM.render( element, document.getElementById('root') ); 我们来看一下这个例子发生了什么？ 调用ReactDOM.render()渲染元素 React以{name：'Sara'}作为props调用Welcome组件 Welcome组件返回一个 Hello，Sara 元素 React DOM有效地更新DOM来匹配 Hello，Sara 注意：组件名称要以大写字母开头，例如，表示一个DOM标签，但表示一个组件，并且要求Welcome在作用范围内（在本模块中或从其他模块引入）。 我们可以创建一个组件，然后呈现多个 function Welcome(props) { return Hello, {props.name}; } function App() { return ( ); } ReactDOM.render( , document.getElementById('root') ); 注意：组件必须返回单个根元素，这也是为什么我们添加了一个来包含所有的元素。 props是只读的 不管将组件声明为functional还是class，它都不能修改自己的props。 看下面这个函数，这样的函数称为‘纯函数’，因为它们不会更改输入，并且相同的输入总是返回相同的结果。 function sum(a, b) { return a + b; } 相比之下，这个函数是不纯的，因为它改变了自己的输入： function withdraw(account, amount) { account.total -= amount; } 再看下组件声明： function Welcome(props) { return Hello, {props.name}; } React很灵活，但有一个严格的规则：所有的React组件必须像纯函数一样不能改变props 当然，应用程序的UI是动态的，在下一节中，我们将介绍“state”，state允许React组件根据用户操作、网络响应或者其他任何内容来更改组件输出，而不会违反此规则。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:18:37 "},"React快速开始/React快速开始（五）State和生命周期.html":{"url":"React快速开始/React快速开始（五）State和生命周期.html","title":"State和生命周期","keywords":"","body":" State and Lifecycle 前面介绍过时钟的例子，通过ReactDOM.render()来改变页面渲染内容 function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 在本节，我们将学习如何让Clock组件真正可重用和可封装， 它可以设置自己的计时器并每秒更新一次 我们可以从封装时钟开始： function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. ); } function tick() { ReactDOM.render( , document.getElementById('root') ); } setInterval(tick, 1000); 但是这并不能满足要求，Clock设置定时器并每秒更新UI的任务应该是Clock的实现细节，不应该由外部来控制。 我们想要的是这样一个组件：Clock组件能够自己更新自己。 ReactDOM.render( , document.getElementById('root') ); 为了实现这一点，我们需要在Clock组件中添加“state”，state与props相似，但它是组件私有的，完全由组件控制。 我们之前提到过（React快速开始（四）组件和props），定义为class的组件具有一些额外功能，组件的state就是这样：只能在定义为class 的组件中使用 将Function转换为Class 可以通过下面五个步骤将时钟functional组件转换为class组件： 创建一个与functional组件相同名称的ES6 class,并继承React.Component 添加一个名为render()的空方法 将functional组件的函数主体移动到render()方法中 在render()方法体中用this.props替换props 删除剩下的空函数声明 functional组件: function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. ); } class组件: class Clock extends React.Component { render() { return ( Hello, world! It is {this.props.date.toLocaleTimeString()}. ); } } Clock组件现在被定义为一个class而不是一个function，这样我们就可以使用一些额外的功能，比如state和组件的生命周期钩子方法（ lifecycle hooks） 在class中添加state 现在把props中的date移到state中，分三个步骤： 将render()方法中的this.props.date 替换为this.state.date class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 添加一个constructor来初始化this.state class Clock extends React.Component { constructor(props) { super(props); this.state = { date: new Date() }; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 注意怎么将props传递给了React.Component的构造函数的,class组件应始终调用父类 的构造函数，并传递props作为参数。 constructor(props) { super(props); this.state = {date: new Date()}; } 关于super关键字 在构造函数中使用时，super关键字单独出现，必须在可以使用this关键字之前使用。此关键字也可用于调用父对象上的函数。 将date属性从 中移除 ReactDOM.render( , document.getElementById('root') ); 结果是这样的 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } ReactDOM.render( , document.getElementById('root') ); 下一步，我们让Clock组件设置它自己的定时器，每秒钟更新自己 向class中添加生命周期方法 在有很多组件的应用程序中，在销毁组件时释放组件占用的资源非常重要。 当Clock第一次添加到DOM时，我们要设置一个定时器， 这在React中称为“挂载”。 当Clock产生的DOM被删除时，我们也想清除该计时器， 这在React中称为“卸载”。 当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来做一些事情： class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 如上componentDidMount和componentWillUnmount， 这些方法称为 生命周期钩子函数 \"lifecycle hooks\" 在组件已经添加到DOM树之后，会执行componentDidMount()，在这里最适合设置一个定时器 componentDidMount() { this.timerID = setInterval( () => this.tick(), 1000 ); } 注意，我们将timerID 保存在this中。 this.props由React设置，this.state具有特殊的含义（根据用户操作改变自身状态），如果需要存储一些不用于更新页面渲染的字段，可以将它添加到类中，比如这里的timerID。 不在render()中使用的，不应该把他放在this.state中，比如这里的timerID 在组件componentWillUnmount()生命周期钩子中拆下计时器： componentWillUnmount() { clearInterval(this.timerID); } 最后，我们实现每秒运行的tick()方法。它使用this.setState()来更新组件状态。 Try it on CodePen class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () => this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } ReactDOM.render( , document.getElementById('root') ); 让我们快速回顾一下发生了什么以及方法调用的顺序(渲染过程)： 1）当传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，所以它new一个当前时间对象来初始化this.state。稍后会更新此状态。（constructor） 2）React调用Clock组件的render()方法,获取应该渲染的内容，更新DOM，使其与Clock的render输出一致。（render ） 3）当Clock组件插入DOM中时，React调用componentDidMount()生命周期钩子。在这里，Clock组件要求浏览器设置一个定时器每秒调用一次tick()。（componentDidMount） 4）浏览器每秒钟调用tick()方法。在这里，Clock组件通过调用setState()更新UI，显示当前时间。因为调用了setState()让React知道state有变化，并再次调用render()方法来了解屏幕上应该呈现是什么。这一次，render()方法中的this.state.date与之前不同，因而render输出将包含更新的时间，并相应地更新真实DOM。 5）如果时钟组件从DOM中删除，React会调用componentWillUnmount()生命周期钩子，让定时器停止计时。 正确使用state 关于setState()方法，你应该知道三件事情： 不要直接修改state 比如下面这样做，不会重新渲染组件 // Wrong this.state.comment = 'Hello'; 应该使用setState() // Correct this.setState({comment: 'Hello'}); 唯一可以直接给state赋值的地方是在 constructor中 state更新可能是异步的 在对setState()多次调用的情况下，为了提高性能，React可能将他们合并，最后一次性更新。 由于this.props和this.state可能会异步更新，所以不应该依靠它们的值计算下一个状态。 例如下面这样更新counter,页面中显示1（把官方文档例子改了一下，感觉这样更能说明问题） class App extends React.Component { constructor(props) { super(props); this.state = { counter:0 }; } componentDidMount() { //这里state并没有立即更新 this.setState({ counter: 5 }); //setState()接收一个对象，this.state.counter还是0 this.setState({ counter: this.state.counter + 1 }); } render(){ return( {this.state.counter} ) } } ReactDOM.render( , document.getElementById('root') ); 下面这样，页面显示6，控制台打印： state: 0 prevState: Object {counter: 5} setState callback1: 6 setState callback2: 6 class App extends React.Component { constructor(props) { super(props); this.state = {counter:0}; } componentDidMount() { this.setState({ counter: 5 },function(){ console.log('setState callback1:',this.state.counter) }); //setState接收一个函数，这里的prevState是上面this.setState执行完之后的state this.setState((prevState, props)=>{ console.log('prevState: ',prevState) return { counter: prevState.counter + 1 }; },function(){ console.log('setState callback2:',this.state.counter) }); console.log('state: ',this.state.counter) } render(){ return( {this.state.counter} ) } } ReactDOM.render( , document.getElementById('root') ); 先执行了console.log('state: ',this.state.counter)，说明setState()是异步更新的 setState()有两种形式 1、setState() 接收一个对象，在setState()中访问this.state可能不是最新的state 2、setState(）接收一个函数，这个函数接收最新的state作为第一个参数，更新应用后的props作为第二个参数 state更新会被合并 当调用setState()时，React会将你提供的对象合并到当前state，例如，state可能包含几个独立变量： constructor(props) { super(props); this.state = { posts: [], comments: [] }; } 你可以调用setState()单独更新一个变量： componentDidMount() { fetchPosts().then(response => { this.setState({ posts: response.posts }); }); fetchComments().then(response => { this.setState({ comments: response.comments }); }); } state合并是浅合并(The merging is shallow)，所以调用this.setState（{comments}）后，this.state.post依然不变，但this.state.comments会被完全替代。 官方文档例子讲得不够明白，我再举一个例子： constructor(props) { super(props); this.state = { info: { value: 1, text: '个人', status: 0 }, array:[1,2] }; } componentDidMount() { this.setState({ info: { value: 2, text: '公司' }, array:[2] },function(){ console.log('state updated:',JSON.stringify(this.state)) }); } 控制台打印结果是： { \"info\":{ \"value\":2, \"text\":\"公司\" }, \"array\":[2] } 所以，记住了！！state更新是浅合并！！state中的属性值会被完全替代 state从上至下传递 state是局部的、组件私有的，一个组件的父组件和子组件都不能知道这个组件是有状态还是无状态，它们也不需要关心这个组件是被定义为函数还是类。 除了拥有并设置它的组件之外，任何其他组件都不能访问这个state。 但是组件可以通过props将它的state传递给子组件 It is {this.state.date.toLocaleTimeString()}. 在自定义组件中也可以 FormattedDate 组件在它的props中添加一个date字段， 在组件内并不care这个date是Clock的 state, 还是Clock的 props, 还是手动写入的 function FormattedDate(props) { return It is {props.date.toLocaleTimeString()}.; } 这通常被称为“自顶向下”或“单向”数据流。 任何state始终由某个特定组件所有，并且这个组件的state只能影响它下面的子组件。 可以将一个组件树的props想象成瀑布，每个组件的state就像一个额外的水源，在某一个点与props会合，并且也往下流动。 为了证明所有组件都是真正孤立互不影响的，我们可以创建一个App组件，呈现三个： function App() { return ( ); } ReactDOM.render( , document.getElementById('root') ); 每个Clock都设置自己的定时器并独立更新。 在React应用中，不管组件是有状态还是无状态，都认为是组件自身的实现细节. 可以在有状态组件中使用无状态组件，反之亦然。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:35:56 "},"React快速开始/React快速开始（六）事件处理.html":{"url":"React快速开始/React快速开始（六）事件处理.html","title":"事件处理","keywords":"","body":" Handling Events React元素事件处理与DOM元素上的事件处理很相似，但有一些语法差异： React事件绑定采用驼峰式命名（onClick），而不是小写(onclick)。 使用JSX，你可以传递一个函数作为事件处理程序，而不是一个字符串。 例如，html中绑定事件 Activate Lasers 在React中略有不同 Activate Lasers 另一个区别是:在React中不能通过return false来阻止默认行为，必须显式调用preventDefault。 例如，为了阻止链接打开新页面的默认行为，在纯HTML中可以这样写： Click me 在React中，必须这样写： function ActionLink() { function handleClick(e) { e.preventDefault(); console.log('The link was clicked.'); } return ( Click me ); } 这里的e对象是一个合成的event, React根据W3C事件规范定义了这些合成event，因此你不必担心跨浏览器的兼容性。 请参阅SyntheticEvent参考指南了解更多信息。 使用React时，通常不需要在创建DOM元素之后调用addEventListener来添加监听器，在元素最初呈现时就可以提供一个监听器。（React采用事件代理机制） 当使用ES6类定义组件时，常见的做法是将事件处理程序作为类方法。 例如，这个Toggle组件有一个按钮，让用户在“ON”和“OFF”状态之间切换： Try it on CodePen class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(prevState => ({ isToggleOn: !prevState.isToggleOn })); } render() { return ( {this.state.isToggleOn ? 'ON' : 'OFF'} ); } } ReactDOM.render( , document.getElementById('root') ); 在JSX回调中必须要注意一点: 在JavaScript中，类方法默认情况下是不会绑定this的， 如果没有给this.handleClick绑定上下文就传递给onClick，那么当该函数实际被调用时，函数内的this是undefined的。 这并不是React的特定行为，它是JavaScript函数如何工作的一部分。通常，如果你引用一个没有()的方法，比如onClick = {this.handleClick}，你应该给该方法绑定上下文。 如果觉得调用bind函数比较麻烦，还有两种方法可以绑定this 1、 属性初始化器 property initializer syntax class LoggingButton extends React.Component { // 这个语法能够handleClick中的`this`被绑定。 // 注意: 这是一个实验性语法 handleClick = () => { console.log('this is:', this); } render() { return ( Click me ); } } 默认情况下，此语法在 Create React App中启用。 2、箭头函数 class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // This syntax ensures `this` is bound within handleClick return ( this.handleClick(e)}> Click me ); } } 这种办法有个问题就是，每次LoggingButton渲染都会重新创建一个回调函数。多数情况下还好，如果这个回调函数作为props传递给下面的子组件，可能会让这些组件进行额外的重新渲染。 箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对 this的词法解析。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值 通常建议在构造函数中绑定或使用属性初始化器语法[property initializer syntax]来避免这种性能问题。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:18:45 "},"React快速开始/React快速开始（七）条件渲染.html":{"url":"React快速开始/React快速开始（七）条件渲染.html","title":"条件渲染","keywords":"","body":" Conditional Rendering 在React中，可以选择在不同条件下渲染不同组件。 这里有两个组件： function UserGreeting(props) { return Welcome back!; } function GuestGreeting(props) { return Please sign up.; } 现在创建一个Greeting组件，根据用户是否登录，显示其中一个组件： function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return ; } return ; } ReactDOM.render( // Try changing to isLoggedIn={true}: , document.getElementById('root') ); 这个例子根据props中的isLoggedIn渲染出不同的内容 元素变量 可以使用变量来存储元素，并且根据条件存储元素，这样可以实现有条件地渲染。 这里有两个组件，注销和登录按钮： function LoginButton(props) { return ( Login ); } function LogoutButton(props) { return ( Logout ); } 现在创建一个有状态组件LoginControl，它将根据当前状态呈现或 Try it on CodePen class LoginControl extends React.Component { constructor(props) { super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = {isLoggedIn: false}; } handleLoginClick() { this.setState({isLoggedIn: true}); } handleLogoutClick() { this.setState({isLoggedIn: false}); } render() { const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) { button = ; } else { button = ; } return ( {button} ); } } ReactDOM.render( , document.getElementById('root') ); 声明变量并使用if语句,这是有条件地呈现组件的一个好方法，但有时希望使用较短的语法。 在JSX中有几种内联条件的方法，如下所述。 逻辑运算符&& （内联If ） 可以在JSX中嵌入任何表达式并将其包裹在花括号中，JavaScript逻辑&&运算符就可以放在{}中。 它可以像这样控制元素呈现：Try it on CodePen function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( Hello! {unreadMessages.length > 0 && You have {unreadMessages.length} unread messages. } ); } const messages = ['React', 'Re: React', 'Re:Re: React']; ReactDOM.render( , document.getElementById('root') ); 在JavaScript中，true && 表达式的结果为表达式的结果，并且 false && 表达式 总是计算为false。 因此，如果条件为真，则&&后面的元素将显示。 如果是false，React会忽略并跳过它。 条件运算符（内联if-Else） 另一种在元素内部条件渲染的方法是使用JavaScript条件运算符 ? true : false. 下面的示例，有条件地呈现一小段文本。 render() { const isLoggedIn = this.state.isLoggedIn; return ( The user is {isLoggedIn ? 'currently' : 'not'} logged in. ); } 也可以用于更大的表达式： render() { const isLoggedIn = this.state.isLoggedIn; return ( {isLoggedIn ? ( ) : ( )} ); } 这个可以根据你认为更易读的方式选择合适的方法。 还要记住，如果条件太复杂，可以试试提取组件 阻止组件渲染 在极少数情况下，可能希望组件隐藏自身，如果是这样，你可以返回一个null。 Try it on CodePen function WarningBanner(props) { if (!props.warn) { return null; } return ( Warning! ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true} this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(prevState => ({ showWarning: !prevState.showWarning })); } render() { return ( {this.state.showWarning ? 'Hide' : 'Show'} ); } } ReactDOM.render( , document.getElementById('root') ); 注意： 从组件的render方法返回null不会影响组件生命周期方法的触发。 例如，componentWillUpdate和componentDidUpdate仍将被调用。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:37:56 "},"React快速开始/React快速开始（八）Lists和Keys.html":{"url":"React快速开始/React快速开始（八）Lists和Keys.html","title":"Lists和Keys","keywords":"","body":" Lists and Keys 我们先来看下在JavaScript中如何转换列表，下面的代码使用map()函数将number数组中的每个数值乘以2，然后返回新的数组。 控制台打印[2, 4, 6, 8, 10] const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) => number * 2); console.log(doubled); 在React中，元素列表的转换与这几乎相同，像下面这样（官方文档啰里啰嗦，其实一看代码就明白了是不） Try it on CodePen const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) => {number} ); 然后将整个listItems数组包含在一个元素中，并将其渲染到DOM中： ReactDOM.render( {listItems}, document.getElementById('root') ); 列表组件 通常会在一个组件中渲染列表,我们可以将前面的例子重构成接受数字数组的一个组件，并输出一个无序的元素列表。 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => {number} ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); 在运行此代码时，会看到一个warning，提示应该为列表项提供一个key, “key”是创建元素列表时需要包含的特殊字符串属性。 在下一节会讨论为什么它很重要。 Try it on CodePen 现在来给list.map()中的列表项添加一个key: function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => {number} ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); Keys key 可以让React知道哪些列表项目已更改、添加或删除。 应该给每一项一个固定的key。 const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) => {number} ); 选择key的最好方法是使用一个字符串来唯一标识列表项,通常会使用数据中的ID作为key： const todoItems = todos.map((todo) => {todo.text} ); 如果没有这样一个id，可以用列表的索引作为key const todoItems = todos.map((todo, index) => // Only do this if items have no stable IDs {todo.text} ); 注意： 如果列表可以重新排序，我们不建议使用索引作为key，因为这会很慢。 可以阅读这篇为什么需要key，给你更深入的解释 提取组件with key key只有在周围有数组的上下文中才有作用。 例如，如果提取了ListItem组件，应该将key放在在数组中的元素上，而不应该在ListItem本身的根元素上。 function ListItem(props) { const value = props.value; return ( // Wrong! There is no need to specify the key here: {value} ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => // Wrong! The key should have been specified here: ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); Example: key的正确用法 Try it on CodePen function ListItem(props) { // Correct! There is no need to specify the key here: return {props.value}; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => // Correct! Key should be specified inside the array. ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); 有一个经验法则：在map()中的元素需要添加key Key在兄弟元素中必须是唯一的 数组中用到的key在兄弟元素中必须是唯一的，但是不需要全局唯一，可以在两个不同的数组中用相同的key. Try it on CodePen function Blog(props) { const sidebar = ( {props.posts.map((post) => {post.title} )} ); const content = props.posts.map((post) => {post.title} {post.content} ); return ( {sidebar} {content} ); } const posts = [ {id: 1, title: 'Hello World', content: 'Welcome to learning React!'}, {id: 2, title: 'Installation', content: 'You can install React from npm.'} ]; ReactDOM.render( , document.getElementById('root') ); key作为React的提示属性，不会传递给组件，所以不要将key作为你想要传递给组件的属性名 const content = posts.map((post) => ); 在上面的例子中，Post组件可以读取props.id，但不能读取到props.key。 将map()嵌入到JSX中 在上面的例子中声明了一个单独的listItems变量并将其包含在JSX中： function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => ); return ( {listItems} ); } JSX允许将任何表达式嵌入到花括号中，所以我们可以内联map()的结果： Try it on CodePen function NumberList(props) { const numbers = props.numbers; return ( {numbers.map((number) => )} ); } 这么做有时候会让代码更清晰，但这种方式也可能被滥用。如果map()里面嵌套很多，可以考虑提取组件。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:38:39 "},"React快速开始/React快速开始（九）表单.html":{"url":"React快速开始/React快速开始（九）表单.html","title":"表单","keywords":"","body":" Forms form元素在React中与在普通html中的表现有些不同，表单元素本身有一些内部状态。 例如，这个HTML中的表单接受一个单一的name： Name: 当用户提交表单时，默认会跳转到新页面，在React中，这也是可以的。 但是在大多数情况下，用JavaScript函数来访问和处理用户输入表单的数据更方便，实现这一点的标准方法是使用一种称为“受控组件”的技术。 受控组件 在HTML中，像，和这些表单元素通常都有自己的状态，并根据用户输入进行更新。 在React中，可变状态通常保存在组件的state中，并且只能使用setState()进行更新。 我们可以结合两者，将React的state作为表单数据的唯一来源，呈现表单的React组件可以控制用户输入时表单的表现。这样一个由React来控制数据的表单元素成为‘受控组件’。 Try it on CodePen class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ''}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('A name was submitted: ' + this.state.value); event.preventDefault(); } render() { return ( Name: ); } } 这个表单元素上设置了value属性，显示的值始终为this.state.value，使React的state成为事实上的的数据源。每一次用户输入都会触发执行handleChange方法来更新显示的值。 在受控组件中，每个可变状态都具有关联的处理函数，这样我们可以直接修改或验证用户输入。 例如，我们要把用户输入的name转换为全部用大写字母，可以把handleChange写成： handleChange(event) { this.setState({value: event.target.value.toUpperCase()}); } textarea 标签 在HTML中，在元素中写文本内容： Hello there, this is some text in a text area 在React中，使用value属性。 这样，使用的表单与使用单行输入input的表单非常类似： class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: 'Please write an essay about your favorite DOM element.' }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('An essay was submitted: ' + this.state.value); event.preventDefault(); } render() { return ( Name: ); } } 注意：this.state.value必须在构造函数中初始化 select标签 在HTML中，用于创建一个下拉列表。 例如， Grapefruit Lime Coconut Mango 注意，Coconut选项因为有‘selected’属性，被默认选中了。 在React中不是使用这个‘selected’属性，而是使用标签上的value属性。在受控组件中这样更方便，因为只需要在一个位置更新。 例如：Try it on CodePen class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: 'coconut'}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('Your favorite flavor is: ' + this.state.value); event.preventDefault(); } render() { return ( Pick your favorite La Croix flavor: Grapefruit Lime Coconut Mango ); } } 总之，这样做能够让，和都很相似 ：它们都接受一个value属性，我们可以通过这个value来控制表单呈现。 处理多个输入 当需要处理多个受控输入元素时，可以给每个元素添加一个name属性，这样可以只用写一个处理函数，在这个函数里根据event.target.name的值来做不同的操作。例如： Try it on CodePen class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( Is going: Number of guests: ); } } 注意，这里使用了ES6计算属性名语法来更新name对应的state属性 this.setState({ [name]: value }); 这与下面ES5代码等同： var partialState = {}; partialState[name] = value; this.setState(partialState); 另外：因为setState()会自动将setState()的输入合并（浅合并）到当前状态，所以我们只需要给setState()部分属性。 受控组件的替代方案 使用受控组件有时会很繁琐，因为需要为每个可变状态编写事件处理程序，并通过React组件管理所有的输入状态。如果老的代码需要转为React或将React应用程序与非React库集成时，这可能特别麻烦。 这种情况下，可能需要检查不受控制的组件(??没明白啥意思)，这是实现表单输入的替代方案。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:18:58 "},"React快速开始/React快速开始（十）state提升.html":{"url":"React快速开始/React快速开始（十）state提升.html","title":"state提升","keywords":"","body":" Lifting State Up 这篇翻译的时候啰里吧嗦，Lifting State Up 译为 ‘state提升’感觉怪怪的，其实就是介绍了一种兄弟组件之间通信的方式。。。 通俗的解释一下： 父组件有子组件A和子组件B，子组件A接收父组件传递的一个函数，这个函数可以更新父组件的state，子组件在用户操作时调用这个函数，这样就可以改变父组件的state了。 那如果父组件把这个state作为props传递给它的另一个子组件B，那结果不就是 子组件A中的操作通过父组件影响了子组件B么。。。 喏，挫挫的翻译开始了。。。 有时候会有几个组件有相同state的情况，我们建议把共享的state提升到最近的共同的祖先上。 这里，我们创建一个温度计算器来计算水在一定温度下是否沸腾。 这里有一个BoilingVerdict组件， 它接收celsius温度作为props，并打印是否可以让水沸腾： function BoilingVerdict(props) { if (props.celsius >= 100) { return The water would boil.; } return The water would not boil.; } 现在，我们创建一个Calculator组件，它有一个可以输入温度，并将输入的值保存在this.state.temperature中，并且会根据当前输入的值渲染BoilingVerdict组件. Try it on CodePen class Calculator extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = {temperature: ''}; } handleChange(e) { this.setState({temperature: e.target.value}); } render() { const temperature = this.state.temperature; return ( Enter temperature in Celsius: ); } } 现在我们除了要输入摄氏温度，还要输入华氏温度，那我们再加一个输入框。我们可以从Calculator中提取一个TemperatureInput组件。 并且提供一个props属性scale，它的值可能是“c”或“f” const scaleNames = { c: 'Celsius', f: 'Fahrenheit' }; class TemperatureInput extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = {temperature: ''}; } handleChange(e) { this.setState({temperature: e.target.value}); } render() { const temperature = this.state.temperature; const scale = this.props.scale; return ( Enter temperature in {scaleNames[scale]}: ); } } 现在Calculator是这样的,有两个输入，输入其中一个时，另一个不更新。 但我们希望能保持同步。 Try it on CodePen class Calculator extends React.Component { render() { return ( ); } } 首先，我们要写两个函数，摄氏度和华氏度的转换，然后返回： function toCelsius(fahrenheit) { return (fahrenheit - 32) * 5 / 9; } function toFahrenheit(celsius) { return (celsius * 9 / 5) + 32; } 这两个函数都是转换数字的。 我们编写另一个函数，将字符串温度和转换器函数作为参数，并返回一个字符串，然后用它来根据一个input来计算另一个input的值。 当temperature不合法时返回空字符串，返回值四舍五入到小数点后三位： function tryConvert(temperature, convert) { const input = parseFloat(temperature); if (Number.isNaN(input)) { return ''; } const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString(); } 例如，tryConvert('abc',toCelsius）返回一个空字符串，而tryConvert('10.22',toFahrenheit）返回'50.396'. 现在两个TemperatureInput组件都将其输入值保存在自己的state。 但是，我们希望这两个输入是相互同步的。当我们更新摄氏温度的输入值时，华氏温度输入框也能显示转换了的华氏温度，反之亦然。 在React中，可以通过将state移动到最接近的共同祖先共享state，这叫做“提升state”。现在从TemperatureInput中删除本地state，并将其移动到Calculator中。 如果计算器拥有共享state，那两个输入中显示的当前温度数据就是这个共享的state中获得,这个共享state可以作为组件的props传递给组件。 但是props是只读的。 当temperature保存在本地状态时，TemperatureInput可以调用this.setState()来更改它。 但是，现在temperature来自parent的props，无法控制temperature。 但是可以通过接收父容器的onTemperatureChange来改变state,当TemperatureInput更新温度时，调用this.props.onTemperatureChange. 翻译不下去了，好啰嗦。。。直接看最后代码吧 Try it on CodePen class TemperatureInput extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); } handleChange(e) { this.props.onTemperatureChange(e.target.value); } render() { const temperature = this.props.temperature; const scale = this.props.scale; return ( Enter temperature in {scaleNames[scale]}: ); } } class Calculator extends React.Component { constructor(props) { super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = {temperature: '', scale: 'c'}; } handleCelsiusChange(temperature) { this.setState({scale: 'c', temperature}); } handleFahrenheitChange(temperature) { this.setState({scale: 'f', temperature}); } render() { const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( ); } } 看下编辑input时会发生什么： React调用在DOM 上onChange事件处理函数。在上面的例子中，就是TemperatureInput组件中的handleChange方法。 TemperatureInput组件中的handleChange方法用输入的值调用this.props.onTemperatureChange() 根据编辑的输入框调用相应的函数，分别是handleCelsiusChange 和handleFahrenheitChange，更新state state改变后，通知React重新获取render方法的返回，得到最新的UI展示对象。 与原有的render返回对比后，更新必要的真实DOM重新渲染 另一个输入框更新为转换后的温度 提升state需要比双向绑定写更多的代码，但有一个好处是：可以很方便的找bug。因为state都是在某一个组件中，这样定位问题的范围就可以大大缩小。 此外，还可以实现自定义逻辑拒绝或转换用户输入。（比如在onChange事件处理函数中对输入进行校验，校验不通过就不更新state,给出提示。） Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:18:39 "},"React快速开始/React快速开始（十一）组合vs继承.html":{"url":"React快速开始/React快速开始（十一）组合vs继承.html","title":"组合vs继承","keywords":"","body":" Composition vs Inheritance 刚接触React的开发人员通常通过继承来实现代码重用，然而我们建议使用组合而不是继承来重用组件之间的代码。React具有强大的组合模型，可以帮助我们解决这些代码重用的问题，而不需要使用继承。 这篇主要是讲 this.props.children 容器（Containment） 一些组件并不能提前知道他们的children是什么。 比如Sidebar和Dialog组件，他们只表示一个通用的盒子，盒子的内容我们自己定义。 例如下面这样, FancyBorder是一个容器组件，里面展示的内容通过props.children获得 function FancyBorder(props) { return ( {props.children} ); } 我们可以通过JSX嵌套传递chilren给组件 Try it on CodePen function WelcomeDialog() { return ( Welcome Thank you for visiting our spacecraft! ); } JSX标签 内的任何内容都将作为props的children属性值传入FancyBorder组件。 因为FancyBorder在一个内部渲染了{props.children}，所以传递的元素将显示在最终输出中。 有时组件中有多个地方需要显示接收到的props内容，那么你可以这样做： Try it on CodePen function SplitPane(props) { return ( {props.left} {props.right} ); } function App() { return ( } right={ } /> ); } React元素（例如和）都只是对象，因此可以像其他数据一样作为props传递。 特殊化（Specialization） 有时一个组件是另一个组件的“special cases”。 例如，我们可以说WelcomeDialog是Dialog的一个特例。在React中这也可以用组合来实现 Try it on CodePen function Dialog(props) { return ( {props.title} {props.message} ); } function WelcomeDialog() { return ( ); } 组合对于定义为类的组件同样适用： Try it on CodePen function Dialog(props) { return ( {props.title} {props.message} {props.children} ); } class SignUpDialog extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = {login: ''}; } handleChange(e) { this.setState({login: e.target.value}); } handleSignUp() { alert(`Welcome aboard, ${this.state.login}!`); } render() { return ( Sign Me Up! ); } } So What About Inheritance? 在Facebook上，有数千个组件使用React，还没有发现任何用例建议使用组件继承。 props和组合已经提供了以明确和安全的方式自定义组件外观和行为所需的所有灵活性。 请记住，组件可以接受任意props，包括原始值，React元素或函数。 如果要在组件之间重用非UI功能，建议将它提取到单独的JavaScript模块中。 组件可以导入并使用函数，对象或类，而不会扩展它。 Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:18:41 "},"React高级指南/React高级指南（一）深入理解JSX.html":{"url":"React高级指南/React高级指南（一）深入理解JSX.html","title":"深入理解JSX","keywords":"","body":"JSX其实就是React.createElement（component，props，... children）函数的语法糖。 JSX代码： Click Me 编译后： React.createElement( MyButton, {color: 'blue', shadowSize: 2}, 'Click Me' ) 如果没有children，也可以用自闭合标签 编译后： React.createElement( 'div', {className: 'sidebar'}, null ) 如果想知道JSX怎么转换成JavaScript，可以在Babel在线编译器上试试 指定React元素类型 JSX标签的首字母就决定了React元素的类型。 首字母大写表示JSX标记指的是React组件。 这些标签会被编译成对命名变量的直接引用，所以如果使用JSX 表达式，Foo必须在可访问范围内。 React必须在可访问范围内 JSX编译后是对React.createElement的调用，所以React库必须始终在JSX代码的访问范围内。 例如，尽管React和CustomButton在JavaScript代码中没有直接用到，但这两个导入都是必需的： import React from 'react'; import CustomButton from './CustomButton'; function WarningButton() { // return React.createElement(CustomButton, {color: 'red'}, null); return ; } 如果是用加载的React，React可以在全局范围内使用，不需要再引入。 对JSX类型使用点符号 还可以使用JSX中的点表示法引用React组件。 如果从一个模块导出很多React组件，例如，MyComponents.DatePicker是一个组件，可以直接在JSX中引用： import React from 'react'; const MyComponents = { DatePicker: function DatePicker(props) { return Imagine a {props.color} datepicker here.; } } function BlueDatePicker() { return ; } 用户定义的组件必须大写开头 当元素类型以小写字母开头时，它表示一个内置的组件，如或，并将一个字符串'div'或'span'传递给React.createElement。 以大写字母开头的类型，如编译为React.createElement（Foo），并与在JavaScript文件中定义或导入的组件对应。 建议用大写字母命名组件，如果你的组件以小写字母开头，在JSX中使用之前请将其分配给大写的变量。 例如，这段代码将无法按预期运行： import React from 'react'; // Wrong! This is a component and should have been capitalized: function hello(props) { // Correct! This use of is legitimate because div is a valid HTML tag: return Hello {props.toWhat}; } function HelloWorld() { // Wrong! React会认为是一个HTML标签，因为不是大写开头: return ; } 下面是正确写法： import React from 'react'; // Correct! This is a component and should be capitalized: function Hello(props) { // Correct! This use of is legitimate because div is a valid HTML tag: return Hello {props.toWhat}; } function HelloWorld() { // Correct! React knows is a component because it's capitalized. return ; } 在运行时确定类型 不能使用通用表达式作为React元素类型。 如果想要使用通用表达式来表示元素类型，请先将其分配给大写的变量。 当你要根据props渲染不同的组件时，会出现这种情况： import React from 'react'; import { PhotoStory, VideoStory } from './stories'; const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // Wrong! JSX type can't be an expression. return ; } 应该先把计算类型的表达式分配给一个大写开头的变量： import React from 'react'; import { PhotoStory, VideoStory } from './stories'; const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // Correct! JSX type can be a capitalized variable. const SpecificStory = components[props.storyType]; return ; } JSX中的Props 在JSX中有几种不同的方式来指定props JavaScript表达式 可以将一个JavaScript表达式传给props，用{}括起来 例如： 对于MyComponent，props.foo的值为表达式1 + 2 + 3 + 4的计算结果:10 在JavaScript中,if语句和for循环不是表达式，所以不能直接在JSX中使用。 可以把逻辑提取出来，结果赋给一个变量，再把这个变量给props 例如： function NumberDescriber(props) { let description; if (props.number % 2 == 0) { description = even; } else { description = odd; } return {props.number} is an {description} number; } 可以在前面的章节中，了解 条件渲染 和 循环 的更多信息 字符串 也可以给props传一个字符串，下面两种方式是等同的 如果要传递没有转义的字符串，下面这两种JSX表达式是等价的 注意：如果这样写： 会被编译成： React.createElement(MyComponent, { message: \"&lt;3\" }); {}中的字符串不会被转义 props默认为“真” 如果没有给一个props传值，它默认为true。 下面这两个JSX表达式是等价的： ES6中，对象 {foo}是 {foo: foo}的简写，而不是 {foo: true}的简写，所以一般不建议使用默认为“真”这种写法（上面第一种写法），容易混淆。但是它确实符合HTML的行为。 参见 ES6 属性定义 spread运算符 现在有一个对象，如果想把对象中的属性分别传给props，而不是把整个对象传给props,可以使用...扩展运算符， 这两个组件是等效的： function App1() { return ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return ; } 在构建通用容器时，扩展属性可能很有用。 但是也可能会传递很多组件不需要的props，所以建议谨慎使用此语法。 JSX中的Children 在有开始标签和结束标签的JSX表达式中，开始和结束标签之间的内容作为一个特殊的props，通过props.children传递。 有几种不同的方法来传递children： 字符串 在开标签和闭标签之间放入字符串文字，访问props.children就会是那个字符串 例如： Hello world! 这样组件中的props.children将只是字符串“Hello world！”，HTML会被转义，所以可以像写HTML一样写JSX This is valid HTML &amp; JSX at the same time. babel会编译为： React.createElement( \"div\", null, \"This is valid HTML & JSX at the same time.\" ); JSX会在行的开始和结尾处移除空格，也会删除空行， 删除与标签相邻的新行; 在字符串文字中间的换行会被压缩成一个空格。下面这些渲染结果都已一样的： Hello World Hello World Hello World Hello World 最后都会编译成： React.createElement( \"div\", null, \"Hello World\" ); JSX元素 可以将多个JSX元素作为Children，这对显示嵌套组件很有用： 也可以像相面这样混合： Here is a list: Item 1 Item 2 一个React组件不能返回多个React元素，但单个JSX表达式可以有多个子元素，因此，如果希望一个组件呈现多个元素，可以将它包含在一个div中。 JavaScript表达式 也可以将任何JavaScript表达式作为Children，并包含在{}中。 例如，这些表达式是等价的： foo {'foo'} 这样可以呈现任意长度的JSX表达式的列表。 例如： function Item(props) { return {props.message}; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( {todos.map((message) => )} ); } JavaScript表达式可以与其他类型的Children混合使用。 这通常用于代替字符串模板： function Hello(props) { return Hello {props.addressee}!; } 函数 插入JSX中的JavaScript表达式计算结果通常是字符串，React元素或内容列表。 但是，props.children可以像其他prop一样传递任何种类的数据，而不仅仅是React知道如何呈现的种类。 例如，如果你有自定义组件，可以将一个回调函数作为props.children： // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i {items}; } function ListOfTenThings() { return ( {(index) => This is item {index} in the list} ); } 这个例子只是为了说明传递给自定义组件的children可以是任何类型，只要组件在呈现之前可以将它转换成React能够理解的东西，上面这种做法并不常见，只是为了拓展你对JSX的理解。 上面的例子可以改写成这样： function Repeat(props) { return {props.children}; } function ListOfTenThings() { let items = []; for (let i = 0; i This is item {i} in the list); } return ( { items} ); } Booleans, Null, and Undefined会被忽略 false，null，undefined和true是有效的children，但它们不会渲染。 下面这些JSX表达式呈现相同： {false} {null} {undefined} {true} 这对于React元素的条件渲染很有用，下面的例子，如果showHeader为true，仅呈现： {showHeader && } 要注意的是： 有一些假值，比如数字0，仍然会被React渲染。 例如，下面的代码将不会按您预期的那样运行，当props.messages为空数组时会渲染出 ‘0’： {props.messages.length && } 要解决这个问题，请确保&&之前的表达式始终为布尔值 {props.messages.length > 0 && } 所以，如果想要一个呈现false，true，null或undefined这样的值中，必须先将其 转换为字符串： My JavaScript variable is {String(myVariable)}. Copyright © chang20159.com 2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 20:32:24 "}}