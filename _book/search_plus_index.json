{"./":{"url":"./","title":"前言","keywords":"","body":"React官方文档译文 打算把React官方文档翻译一遍，主要是为了让知识更系统些，翻译过程中可能会加入一点自己的理解。 主要是这三块内容，会持续更新。 React快速开始 React高级指南 React参考 React官方博客 如果您有发现翻译不当的地方，欢迎指正。左上角有个 EDIT THIS PAGE，点击可以直接编辑。 如果点击左侧目录没有响应，刷新一下试试。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-23 17:04:09 "},"React快速开始/React快速开始（一）安装.html":{"url":"React快速开始/React快速开始（一）安装.html","title":"安装","keywords":"","body":" Installation 安装 react很灵活，可用于各种项目。 可以使用它创建新的应用程序，也可以引入到现有的代码库中。看看下面哪一种方式是你需要的。 如果只想试一试React 如果只想试一试React，那就使用CodePen，不需要安装任何东西，直接写React代码就能看到效果。 可以试一下 Hello World example code 如果使用自己的文本编辑器，可以像下面这样写一个html文件，就可以在本地直接用浏览器打开看到效果。 Hello World ReactDOM.render( Hello, world!, document.getElementById('root') ); 创建React应用程序 看这里 >> create-react-app，这是构建新的React单页应用程序的最佳方法，能够使用JavaScript最新特性 npm install -g create-react-app create-react-app my-app cd my-app npm start 这样创建的应用程序是零配置的，没有使用babel和webpack 在已有项目中引入React 一个经典的React项目应该具备这些： 包管理器 比如Yarn 或者 npm，使用它可以更方便的管理第三方包，并且很方便的安装和更新包 打包工具 比如webpack 或者 Browserify，它可以让你编写模块化代码并将各个模块打包在一起，以优化加载时间。 编译器 如Babel， 可以将新的JavaScript特性编译成适用于旧版浏览器的JavaScript代码。 在项目中安装React yarn init yarn add react react-dom npm install --save react react-dom npm init Yarn 和 npm 都是从npm registry下载包的 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 16:10:17 "},"React快速开始/React快速开始（二）使用JSX.html":{"url":"React快速开始/React快速开始（二）使用JSX.html","title":"使用JSX","keywords":"","body":" Introducing JSX 使用JSX JSX，全称 JavaScript XML ，一种类XML语言，它是JavaScript的语法扩展。 没有使用JSX var element = React.createElement( \"h1\", null, \"Hello, world!\" ); 使用JSX const element = Hello, world!; 可以看出使用JSX可以让代码可读性更高、语义更清晰、更易维护。JSX类似于模板引擎，但功能更强大 语法 1、可以在JSX中嵌入任何JavaScript表达式，方法是将其包装在花括号中。 const element = (Hello, {formatName(user)}!); 2、将JSX分割成多行，可读性更好。这不是必需的，但在这样做的时候，建议把它放在括号中，以避免自动分号插入的陷阱。 const element = ( Hello, {formatName(user)}! ); 3、JSX也是一个表达式，编译后，JSX表达式就是常规的JavaScript对象。这意味着可以在if语句和for循环中使用JSX、将其分配给变量、接受它作为参数、并从函数返回它 function getGreeting(user) { if (user) { return Hello, {formatName(user)}!; } return Hello, Stranger.; } 4、用JSX指定属性 引号和花括号不能同时使用 注意: 在JSX中，属性使用驼峰式命名，例如class变为className,font-size变为fontSize //用引号指定字符串作为属性 const element = ; //使用花括号将JavaScript表达式嵌入到属性中 const element = ; 5、用JSX指定children 如果标签为空，则可以使用/>关闭 const element = ; JSX标签也可以有children const element = ( Hello! Good to see you here. ) 6、JSX可以防止脚本注入攻击，在JSX中嵌入用户输入是安全的 默认情况下，React DOM会在渲染之前转义嵌入在JSX中的任何值，确保不会注入任何未明确写入应用程序的内容。 例如： {'First &middot; Second'} 花括号中的内容并不会展示为 First · Second在呈现之前，所有内容都将转换为字符串。 这有助于防止XSS（跨站点脚本）攻击。 const title = response.potentiallyMaliciousInput; // 这样是安全的 const element = {title}; 7、JSX的对象表示Babel将JSX编译成React.createElement（）调用。这两个例子是一样的： const element = ( Hello, world! ); ReactDOM.render(element, document.getElementById(\"root\")); 编译后： const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); ReactDOM.render(element, document.getElementById(\"root\")); React.createElement（）会执行一些检查帮助你编写无错误代码， 它会创建一个基本类似于如下所示的对象： // 注意：这个结构被简化了 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world' } }; 这些对象称为“React元素”, React读取这些对象，并使用它们构造DOM呈现页面最新状态。 另外，使用ReactDOM.render()，React可以嵌入到使用其他JavaScript UI库的应用程序中。 JSX使用经验 使用事件 JSX采用驼峰写法来描述事件名称，例如onChange、onClick 使用样式 样式属性名用-连接的都采用驼峰写法，例如font-size : fontSize,background-color:backgroundColor 静态样式 动态样式 let spanStyle = { color: '#ff6633', fontSize: '14px' }; 使用表达式 {}里面都是表达式，那就可以这样写 render(){ return( { this.state.show ? ( 噢噢噢噢 ) : null } ) } 使用注释 render(){ return( 噢噢噢噢 { //这里是注释 } ) } Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-16 22:56:27 "},"React快速开始/React快速开始（三）渲染元素.html":{"url":"React快速开始/React快速开始（三）渲染元素.html","title":"渲染元素","keywords":"","body":" Rendering Elements 渲染元素 元素是React应用最小构建块，每一个元素都描述了呈现在屏幕上的内容。不同于真实的DOM元素，React元素就是一个普通的对象，创建成本很低，React DOM负责更新真实DOM与React元素匹配。 关于组件、元素和实例可以看这个 React Components, Elements, and Instances 将元素渲染到DOM中 假设你的HTML文件中有一个,这个节点里面的内容都由 React DOM来管理。 使用React构建的应用程序通常具有单个根DOM节点，要将React元素渲染到根DOM节点中，需要将他们传递给ReactDOM.render() const element = Hello, world; ReactDOM.render( element, document.getElementById('root') ); 更新已渲染元素 React元素是不可变的，创建元素后无法更改其子项或属性,一个元素就像一个电影中的一帧：它代表了某个时间点的UI。 根据我们目前的知识，更新UI的唯一方法是创建一个新元素，并将其传递给ReactDOM.render()。 看下面这个显示时间的例子,每秒钟都会执行一次ReactDOM.render() function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 实际上，大多数React应用只会调用ReactDOM.render()一次,在接下来的章节中，我们会学习如何将这些代码封装到有状态的组件中。 React仅在必要时更新 尽管我们创建了一个描述整个UI树的元素，但只有内容改变的节点才被React DOM更新。因为ReactDOM会将元素及其子元素与之前的元素进行比较，并且只更新实际改变的DOM。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:02:29 "},"React快速开始/React快速开始（四）组件和props.html":{"url":"React快速开始/React快速开始（四）组件和props.html","title":"组件和props","keywords":"","body":" Components and Props 组件和Props 使用组件可以将UI拆分成独立的可重复使用的部分，然后可以单独考虑每个组件的渲染。从概念上来讲，组件就像JavaScript函数，接受任意输入（称为“props”），并返回描述页面呈现的React元素。 函数组件和类组件（Functional and Class ） 定义组件最简单的方法是：编写一个JavaScript函数： function Welcome(props) { return Hello, {props.name}; } 这个函数是一个有效的React组件，因为它接受一个单一的“props”对象参数并返回一个React元素。 我们将这样的组件称为“functional组件”，因为它们在字面上是一个JavaScript函数。 还可以使用ES6类来定义组件： class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } 上面这两个组件是等同的，class组件有一些额外的功能（state、钩子函数），这会在下一章节讨论，这里先使用functional组件来讨论 渲染组件 之前我们遇到的元素，都是DOM标签： const element = ; 我们也可以自定义元素，代表一个组件 const element = ; 当React知道这是一个表示用户定义的元素时，它将JSX属性作为单个对象传递给该组件。 我们称这个对象为“props”。例如： Try it on CodePen function Welcome(props) { return Hello, {props.name}; } const element = ; ReactDOM.render( element, document.getElementById('root') ); 我们来看一下这个例子发生了什么？ 调用ReactDOM.render()渲染元素 React以{name：'Sara'}作为props调用Welcome组件 Welcome组件返回一个 Hello，Sara 元素 React DOM有效地更新DOM来匹配 Hello，Sara 注意：组件名称要以大写字母开头，例如，表示一个DOM标签，但表示一个组件，并且要求Welcome在作用范围内（在本模块中或从其他模块引入）。 我们可以创建一个组件，然后呈现多个 function Welcome(props) { return Hello, {props.name}; } function App() { return ( ); } ReactDOM.render( , document.getElementById('root') ); 注意：组件必须返回单个根元素，这也是为什么我们添加了一个来包含所有的元素。 props是只读的 不管将组件声明为functional还是class，它都不能修改自己的props。 看下面这个函数，这样的函数称为‘纯函数’，因为它们不会更改输入，并且相同的输入总是返回相同的结果。 function sum(a, b) { return a + b; } 相比之下，这个函数是不纯的，因为它改变了自己的输入： function withdraw(account, amount) { account.total -= amount; } 再看下组件声明： function Welcome(props) { return Hello, {props.name}; } React很灵活，但有一个严格的规则：所有的React组件必须像纯函数一样不能改变props 当然，应用程序的UI是动态的，在下一节中，我们将介绍“state”，state允许React组件根据用户操作、网络响应或者其他任何内容来更改组件输出，而不会违反此规则。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:02:27 "},"React快速开始/React快速开始（五）State和生命周期.html":{"url":"React快速开始/React快速开始（五）State和生命周期.html","title":"State和生命周期","keywords":"","body":" State and Lifecycle State 和 生命周期 前面介绍过时钟的例子，通过ReactDOM.render()来改变页面渲染内容 function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 在本节，我们将学习如何让Clock组件真正可重用和可封装， 它可以设置自己的计时器并每秒更新一次 我们可以从封装时钟开始： function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. ); } function tick() { ReactDOM.render( , document.getElementById('root') ); } setInterval(tick, 1000); 但是这并不能满足要求，Clock设置定时器并每秒更新UI的任务应该是Clock的实现细节，不应该由外部来控制。 我们想要的是这样一个组件：Clock组件能够自己更新自己。 ReactDOM.render( , document.getElementById('root') ); 为了实现这一点，我们需要在Clock组件中添加“state”，state与props相似，但它是组件私有的，完全由组件控制。 我们之前提到过（React快速开始（四）组件和props），定义为class的组件具有一些额外功能，组件的state就是这样：只能在定义为class 的组件中使用 将Function转换为Class 可以通过下面五个步骤将时钟functional组件转换为class组件： 创建一个与functional组件相同名称的ES6 class,并继承React.Component 添加一个名为render()的空方法 将functional组件的函数主体移动到render()方法中 在render()方法体中用this.props替换props 删除剩下的空函数声明 functional组件: function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. ); } class组件: class Clock extends React.Component { render() { return ( Hello, world! It is {this.props.date.toLocaleTimeString()}. ); } } Clock组件现在被定义为一个class而不是一个function，这样我们就可以使用一些额外的功能，比如state和组件的生命周期钩子方法（ lifecycle hooks） 在class中添加state 现在把props中的date移到state中，分三个步骤： 将render()方法中的this.props.date 替换为this.state.date class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 添加一个constructor来初始化this.state class Clock extends React.Component { constructor(props) { super(props); this.state = { date: new Date() }; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 注意怎么将props传递给了React.Component的构造函数的,class组件应始终调用父类 的构造函数，并传递props作为参数。 constructor(props) { super(props); this.state = {date: new Date()}; } 关于super关键字 在构造函数中使用时，super关键字单独出现，必须在可以使用this关键字之前使用。此关键字也可用于调用父对象上的函数。 将date属性从 中移除 ReactDOM.render( , document.getElementById('root') ); 结果是这样的 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } ReactDOM.render( , document.getElementById('root') ); 下一步，我们让Clock组件设置它自己的定时器，每秒钟更新自己 向class中添加生命周期方法 在有很多组件的应用程序中，在销毁组件时释放组件占用的资源非常重要。 当Clock第一次添加到DOM时，我们要设置一个定时器， 这在React中称为“挂载”。 当Clock产生的DOM被删除时，我们也想清除该计时器， 这在React中称为“卸载”。 当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来做一些事情： class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } 如上componentDidMount和componentWillUnmount， 这些方法称为 生命周期钩子函数 \"lifecycle hooks\" 在组件已经添加到DOM树之后，会执行componentDidMount()，在这里最适合设置一个定时器 componentDidMount() { this.timerID = setInterval( () => this.tick(), 1000 ); } 注意，我们将timerID 保存在this中。 this.props由React设置，this.state具有特殊的含义（根据用户操作改变自身状态），如果需要存储一些不用于更新页面渲染的字段，可以将它添加到类中，比如这里的timerID。 不在render()中使用的，不应该把他放在this.state中，比如这里的timerID 在组件componentWillUnmount()生命周期钩子中拆下计时器： componentWillUnmount() { clearInterval(this.timerID); } 最后，我们实现每秒运行的tick()方法。它使用this.setState()来更新组件状态。 Try it on CodePen class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () => this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } ReactDOM.render( , document.getElementById('root') ); 让我们快速回顾一下发生了什么以及方法调用的顺序(渲染过程)： 1）当传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，所以它new一个当前时间对象来初始化this.state。稍后会更新此状态。（constructor） 2）React调用Clock组件的render()方法,获取应该渲染的内容，更新DOM，使其与Clock的render输出一致。（render ） 3）当Clock组件插入DOM中时，React调用componentDidMount()生命周期钩子。在这里，Clock组件要求浏览器设置一个定时器每秒调用一次tick()。（componentDidMount） 4）浏览器每秒钟调用tick()方法。在这里，Clock组件通过调用setState()更新UI，显示当前时间。因为调用了setState()让React知道state有变化，并再次调用render()方法来了解屏幕上应该呈现是什么。这一次，render()方法中的this.state.date与之前不同，因而render输出将包含更新的时间，并相应地更新真实DOM。 5）如果时钟组件从DOM中删除，React会调用componentWillUnmount()生命周期钩子，让定时器停止计时。 正确使用state 关于setState()方法，你应该知道三件事情： 不要直接修改state 比如下面这样做，不会重新渲染组件 // Wrong this.state.comment = 'Hello'; 应该使用setState() // Correct this.setState({comment: 'Hello'}); 唯一可以直接给state赋值的地方是在 constructor中 state更新可能是异步的 在对setState()多次调用的情况下，为了提高性能，React可能将他们合并，最后一次性更新。 由于this.props和this.state可能会异步更新，所以不应该依靠它们的值计算下一个状态。 例如下面这样更新counter,页面中显示1（把官方文档例子改了一下，感觉这样更能说明问题） class App extends React.Component { constructor(props) { super(props); this.state = { counter:0 }; } componentDidMount() { //这里state并没有立即更新 this.setState({ counter: 5 }); //setState()接收一个对象，this.state.counter还是0 this.setState({ counter: this.state.counter + 1 }); } render(){ return( {this.state.counter} ) } } ReactDOM.render( , document.getElementById('root') ); 下面这样，页面显示6，控制台打印： state: 0 prevState: Object {counter: 5} setState callback1: 6 setState callback2: 6 class App extends React.Component { constructor(props) { super(props); this.state = {counter:0}; } componentDidMount() { this.setState({ counter: 5 },function(){ console.log('setState callback1:',this.state.counter) }); //setState接收一个函数，这里的prevState是上面this.setState执行完之后的state this.setState((prevState, props)=>{ console.log('prevState: ',prevState) return { counter: prevState.counter + 1 }; },function(){ console.log('setState callback2:',this.state.counter) }); console.log('state: ',this.state.counter) } render(){ return( {this.state.counter} ) } } ReactDOM.render( , document.getElementById('root') ); 先执行了console.log('state: ',this.state.counter)，说明setState()是异步更新的 setState()有两种形式 1、setState() 接收一个对象，在setState()中访问this.state可能不是最新的state 2、setState(）接收一个函数，这个函数接收最新的state作为第一个参数，更新应用后的props作为第二个参数 state更新会被合并 当调用setState()时，React会将你提供的对象合并到当前state，例如，state可能包含几个独立变量： constructor(props) { super(props); this.state = { posts: [], comments: [] }; } 你可以调用setState()单独更新一个变量： componentDidMount() { fetchPosts().then(response => { this.setState({ posts: response.posts }); }); fetchComments().then(response => { this.setState({ comments: response.comments }); }); } state合并是浅合并(The merging is shallow)，所以调用this.setState（{comments}）后，this.state.post依然不变，但this.state.comments会被完全替代。 官方文档例子讲得不够明白，我再举一个例子： constructor(props) { super(props); this.state = { info: { value: 1, text: '个人', status: 0 }, array:[1,2] }; } componentDidMount() { this.setState({ info: { value: 2, text: '公司' }, array:[2] },function(){ console.log('state updated:',JSON.stringify(this.state)) }); } 控制台打印结果是： { \"info\":{ \"value\":2, \"text\":\"公司\" }, \"array\":[2] } 所以，记住了！！state更新是浅合并！！state中的属性值会被完全替代 state从上至下传递 state是局部的、组件私有的，一个组件的父组件和子组件都不能知道这个组件是有状态还是无状态，它们也不需要关心这个组件是被定义为函数还是类。 除了拥有并设置它的组件之外，任何其他组件都不能访问这个state。 但是组件可以通过props将它的state传递给子组件 It is {this.state.date.toLocaleTimeString()}. 在自定义组件中也可以 FormattedDate 组件在它的props中添加一个date字段， 在组件内并不care这个date是Clock的 state, 还是Clock的 props, 还是手动写入的 function FormattedDate(props) { return It is {props.date.toLocaleTimeString()}.; } 这通常被称为“自顶向下”或“单向”数据流。 任何state始终由某个特定组件所有，并且这个组件的state只能影响它下面的子组件。 可以将一个组件树的props想象成瀑布，每个组件的state就像一个额外的水源，在某一个点与props会合，并且也往下流动。 为了证明所有组件都是真正孤立互不影响的，我们可以创建一个App组件，呈现三个： function App() { return ( ); } ReactDOM.render( , document.getElementById('root') ); 每个Clock都设置自己的定时器并独立更新。 在React应用中，不管组件是有状态还是无状态，都认为是组件自身的实现细节. 可以在有状态组件中使用无状态组件，反之亦然。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:03:11 "},"React快速开始/React快速开始（六）事件处理.html":{"url":"React快速开始/React快速开始（六）事件处理.html","title":"事件处理","keywords":"","body":" Handling Events 事件处理 React元素事件处理与DOM元素上的事件处理很相似，但有一些语法差异： React事件绑定采用驼峰式命名（onClick），而不是小写(onclick)。 使用JSX，你可以传递一个函数作为事件处理程序，而不是一个字符串。 例如，html中绑定事件 Activate Lasers 在React中略有不同 Activate Lasers 另一个区别是:在React中不能通过return false来阻止默认行为，必须显式调用preventDefault。 还有在react中onClick最终要绑定在DOM元素上才有效 例如，为了阻止链接打开新页面的默认行为，在纯HTML中可以这样写： Click me 在React中，必须这样写： function ActionLink() { function handleClick(e) { e.preventDefault(); console.log('The link was clicked.'); } return ( Click me ); } 这里的e对象是一个合成的event, React根据W3C事件规范定义了这些合成event，因此你不必担心跨浏览器的兼容性。 请参阅SyntheticEvent参考指南了解更多信息。 使用React时，通常不需要在创建DOM元素之后调用addEventListener来添加监听器，在元素最初呈现时就可以提供一个监听器。（React采用事件代理机制） 当使用ES6类定义组件时，常见的做法是将事件处理程序作为类方法。 例如，这个Toggle组件有一个按钮，让用户在“ON”和“OFF”状态之间切换： Try it on CodePen class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(prevState => ({ isToggleOn: !prevState.isToggleOn })); } render() { return ( {this.state.isToggleOn ? 'ON' : 'OFF'} ); } } ReactDOM.render( , document.getElementById('root') ); 在JSX回调中必须要注意一点: 在JavaScript中，类方法默认情况下是不会绑定this的， 如果没有给this.handleClick绑定上下文就传递给onClick，那么当该函数实际被调用时，函数内的this是undefined的。 这并不是React的特定行为，它是JavaScript函数如何工作的一部分。通常，如果你引用一个没有()的方法，比如onClick = {this.handleClick}，你应该给该方法绑定上下文。 如果觉得调用bind函数比较麻烦，还有两种方法可以绑定this 1、 属性初始化器 property initializer syntax class LoggingButton extends React.Component { // 这个语法能够handleClick中的`this`被绑定。 // 注意: 这是一个实验性语法 handleClick = () => { console.log('this is:', this); } render() { return ( Click me ); } } 默认情况下，此语法在 Create React App中启用。 2、箭头函数 class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // This syntax ensures `this` is bound within handleClick return ( this.handleClick(e)}> Click me ); } } 这种办法有个问题就是，每次LoggingButton渲染都会重新创建一个回调函数。多数情况下还好，如果这个回调函数作为props传递给下面的子组件，可能会让这些组件进行额外的重新渲染。 箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对 this的词法解析。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值 通常建议在构造函数中绑定或使用属性初始化器语法[property initializer syntax]来避免这种性能问题。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:05:33 "},"React快速开始/React快速开始（七）条件渲染.html":{"url":"React快速开始/React快速开始（七）条件渲染.html","title":"条件渲染","keywords":"","body":" Conditional Rendering 在React中，可以选择在不同条件下渲染不同组件。 这里有两个组件： function UserGreeting(props) { return Welcome back!; } function GuestGreeting(props) { return Please sign up.; } 现在创建一个Greeting组件，根据用户是否登录，显示其中一个组件： function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return ; } return ; } ReactDOM.render( // Try changing to isLoggedIn={true}: , document.getElementById('root') ); 这个例子根据props中的isLoggedIn渲染出不同的内容 元素变量 可以使用变量来存储元素，并且根据条件存储元素，这样可以实现有条件地渲染。 这里有两个组件，注销和登录按钮： function LoginButton(props) { return ( Login ); } function LogoutButton(props) { return ( Logout ); } 现在创建一个有状态组件LoginControl，它将根据当前状态呈现或 Try it on CodePen class LoginControl extends React.Component { constructor(props) { super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = {isLoggedIn: false}; } handleLoginClick() { this.setState({isLoggedIn: true}); } handleLogoutClick() { this.setState({isLoggedIn: false}); } render() { const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) { button = ; } else { button = ; } return ( {button} ); } } ReactDOM.render( , document.getElementById('root') ); 声明变量并使用if语句,这是有条件地呈现组件的一个好方法，但有时希望使用较短的语法。 在JSX中有几种内联条件的方法，如下所述。 逻辑运算符&& （内联If ） 可以在JSX中嵌入任何表达式并将其包裹在花括号中，JavaScript逻辑&&运算符就可以放在{}中。 它可以像这样控制元素呈现：Try it on CodePen function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( Hello! {unreadMessages.length > 0 && You have {unreadMessages.length} unread messages. } ); } const messages = ['React', 'Re: React', 'Re:Re: React']; ReactDOM.render( , document.getElementById('root') ); 在JavaScript中，true && 表达式的结果为表达式的结果，并且 false && 表达式 总是计算为false。 因此，如果条件为真，则&&后面的元素将显示。 如果是false，React会忽略并跳过它。 条件运算符（内联if-Else） 另一种在元素内部条件渲染的方法是使用JavaScript条件运算符 ? true : false. 下面的示例，有条件地呈现一小段文本。 render() { const isLoggedIn = this.state.isLoggedIn; return ( The user is {isLoggedIn ? 'currently' : 'not'} logged in. ); } 也可以用于更大的表达式： render() { const isLoggedIn = this.state.isLoggedIn; return ( {isLoggedIn ? ( ) : ( )} ); } 这个可以根据你认为更易读的方式选择合适的方法。 还要记住，如果条件太复杂，可以试试提取组件 阻止组件渲染 在极少数情况下，可能希望组件隐藏自身，如果是这样，你可以返回一个null。 Try it on CodePen function WarningBanner(props) { if (!props.warn) { return null; } return ( Warning! ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true} this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(prevState => ({ showWarning: !prevState.showWarning })); } render() { return ( {this.state.showWarning ? 'Hide' : 'Show'} ); } } ReactDOM.render( , document.getElementById('root') ); 注意： 从组件的render方法返回null不会影响组件生命周期方法的触发。 例如，componentWillUpdate和componentDidUpdate仍将被调用。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-15 11:37:56 "},"React快速开始/React快速开始（八）Lists和Keys.html":{"url":"React快速开始/React快速开始（八）Lists和Keys.html","title":"Lists和Keys","keywords":"","body":" Lists and Keys Lists 和 Keys 我们先来看下在JavaScript中如何转换列表，下面的代码使用map()函数将number数组中的每个数值乘以2，然后返回新的数组。 控制台打印[2, 4, 6, 8, 10] const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) => number * 2); console.log(doubled); 在React中，元素列表的转换与这几乎相同，像下面这样（官方文档啰里啰嗦，其实一看代码就明白了是不） Try it on CodePen const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) => {number} ); 然后将整个listItems数组包含在一个元素中，并将其渲染到DOM中： ReactDOM.render( {listItems}, document.getElementById('root') ); 列表组件 通常会在一个组件中渲染列表,我们可以将前面的例子重构成接受数字数组的一个组件，并输出一个无序的元素列表。 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => {number} ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); 在运行此代码时，会看到一个warning，提示应该为列表项提供一个key, “key”是创建元素列表时需要包含的特殊字符串属性。 在下一节会讨论为什么它很重要。 Try it on CodePen 现在来给list.map()中的列表项添加一个key: function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => {number} ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); Keys key 可以让React知道哪些列表项目已更改、添加或删除。 应该给每一项一个固定的key。 const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) => {number} ); 选择key的最好方法是使用一个字符串来唯一标识列表项,通常会使用数据中的ID作为key： const todoItems = todos.map((todo) => {todo.text} ); 如果没有这样一个id，可以用列表的索引作为key const todoItems = todos.map((todo, index) => // Only do this if items have no stable IDs {todo.text} ); 注意： 如果列表可以重新排序，我们不建议使用索引作为key，因为这会很慢。 可以阅读这篇为什么需要key，给你更深入的解释 提取组件with key key只有在周围有数组的上下文中才有作用。 例如，如果提取了ListItem组件，应该将key放在在数组中的元素上，而不应该在ListItem本身的根元素上。 function ListItem(props) { const value = props.value; return ( // Wrong! There is no need to specify the key here: {value} ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => // Wrong! The key should have been specified here: ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); Example: key的正确用法 Try it on CodePen function ListItem(props) { // Correct! There is no need to specify the key here: return {props.value}; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => // Correct! Key should be specified inside the array. ); return ( {listItems} ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( , document.getElementById('root') ); 有一个经验法则：在map()中的元素需要添加key Key在兄弟元素中必须是唯一的 数组中用到的key在兄弟元素中必须是唯一的，但是不需要全局唯一，可以在两个不同的数组中用相同的key. Try it on CodePen function Blog(props) { const sidebar = ( {props.posts.map((post) => {post.title} )} ); const content = props.posts.map((post) => {post.title} {post.content} ); return ( {sidebar} {content} ); } const posts = [ {id: 1, title: 'Hello World', content: 'Welcome to learning React!'}, {id: 2, title: 'Installation', content: 'You can install React from npm.'} ]; ReactDOM.render( , document.getElementById('root') ); key作为React的提示属性，不会传递给组件，所以不要将key作为你想要传递给组件的属性名 const content = posts.map((post) => ); 在上面的例子中，Post组件可以读取props.id，但不能读取到props.key。 将map()嵌入到JSX中 在上面的例子中声明了一个单独的listItems变量并将其包含在JSX中： function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) => ); return ( {listItems} ); } JSX允许将任何表达式嵌入到花括号中，所以我们可以内联map()的结果： Try it on CodePen function NumberList(props) { const numbers = props.numbers; return ( {numbers.map((number) => )} ); } 这么做有时候会让代码更清晰，但这种方式也可能被滥用。如果map()里面嵌套很多，可以考虑提取组件。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:04:32 "},"React快速开始/React快速开始（九）表单.html":{"url":"React快速开始/React快速开始（九）表单.html","title":"表单","keywords":"","body":" Forms form元素在React中与在普通html中的表现有些不同，表单元素本身有一些内部状态。 例如，这个HTML中的表单接受一个单一的name： Name: 当用户提交表单时，默认会跳转到新页面，在React中，这也是可以的。 但是在大多数情况下，用JavaScript函数来访问和处理用户输入表单的数据更方便，实现这一点的标准方法是使用一种称为“受控组件”的技术。 受控组件 在HTML中，像，和这些表单元素通常都有自己的状态，并根据用户输入进行更新。 在React中，可变状态通常保存在组件的state中，并且只能使用setState()进行更新。 我们可以结合两者，将React的state作为表单数据的唯一来源，呈现表单的React组件可以控制用户输入时表单的表现。这样一个由React来控制数据的表单元素成为‘受控组件’。 Try it on CodePen class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ''}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('A name was submitted: ' + this.state.value); event.preventDefault(); } render() { return ( Name: ); } } 这个表单元素上设置了value属性，显示的值始终为this.state.value，使React的state成为事实上的的数据源。每一次用户输入都会触发执行handleChange方法来更新显示的值。 在受控组件中，每个可变状态都具有关联的处理函数，这样我们可以直接修改或验证用户输入。 例如，我们要把用户输入的name转换为全部用大写字母，可以把handleChange写成： handleChange(event) { this.setState({value: event.target.value.toUpperCase()}); } textarea 标签 在HTML中，在元素中写文本内容： Hello there, this is some text in a text area 在React中，使用value属性。 这样，使用的表单与使用单行输入input的表单非常类似： class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: 'Please write an essay about your favorite DOM element.' }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('An essay was submitted: ' + this.state.value); event.preventDefault(); } render() { return ( Name: ); } } 注意：this.state.value必须在构造函数中初始化 select标签 在HTML中，用于创建一个下拉列表。 例如， Grapefruit Lime Coconut Mango 注意，Coconut选项因为有‘selected’属性，被默认选中了。 在React中不是使用这个‘selected’属性，而是使用标签上的value属性。在受控组件中这样更方便，因为只需要在一个位置更新。 例如：Try it on CodePen class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: 'coconut'}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('Your favorite flavor is: ' + this.state.value); event.preventDefault(); } render() { return ( Pick your favorite La Croix flavor: Grapefruit Lime Coconut Mango ); } } 总之，这样做能够让，和都很相似 ：它们都接受一个value属性，我们可以通过这个value来控制表单呈现。 处理多个输入 当需要处理多个受控输入元素时，可以给每个元素添加一个name属性，这样可以只用写一个处理函数，在这个函数里根据event.target.name的值来做不同的操作。例如： Try it on CodePen class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( Is going: Number of guests: ); } } 注意，这里使用了ES6计算属性名语法来更新name对应的state属性 this.setState({ [name]: value }); 这与下面ES5代码等同： var partialState = {}; partialState[name] = value; this.setState(partialState); 另外：因为setState()会自动将setState()的输入合并（浅合并）到当前状态，所以我们只需要给setState()部分属性。 受控组件的替代方案 使用受控组件有时会很繁琐，因为需要为每个可变状态编写事件处理程序，并通过React组件管理所有的输入状态。如果老的代码需要转为React或将React应用程序与非React库集成时，这可能特别麻烦。 这种情况下，可能需要考虑不受控制的组件，这是实现表单输入的替代方案。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 20:12:02 "},"React快速开始/React快速开始（十）state提升.html":{"url":"React快速开始/React快速开始（十）state提升.html","title":"state提升","keywords":"","body":" Lifting State Up state提升 这篇翻译的时候啰里吧嗦，其实就是介绍了一种兄弟组件之间通信的方式。。。 通俗的解释一下： 父组件有子组件A和子组件B，子组件A接收父组件传递的一个函数，这个函数可以更新父组件的state，子组件在用户操作时调用这个函数，这样就可以改变父组件的state了。 那如果父组件把这个state作为props传递给它的另一个子组件B，那结果不就是 子组件A中的操作通过父组件影响了子组件B么。。。 喏，挫挫的翻译开始了。。。 有时候会有几个组件有相同state的情况，我们建议把共享的state提升到最近的共同的祖先上。 这里，我们创建一个温度计算器来计算水在一定温度下是否沸腾。 这里有一个BoilingVerdict组件， 它接收celsius温度作为props，并打印是否可以让水沸腾： function BoilingVerdict(props) { if (props.celsius >= 100) { return The water would boil.; } return The water would not boil.; } 现在，我们创建一个Calculator组件，它有一个可以输入温度，并将输入的值保存在this.state.temperature中，并且会根据当前输入的值渲染BoilingVerdict组件. Try it on CodePen class Calculator extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = {temperature: ''}; } handleChange(e) { this.setState({temperature: e.target.value}); } render() { const temperature = this.state.temperature; return ( Enter temperature in Celsius: ); } } 现在我们除了要输入摄氏温度，还要输入华氏温度，那我们再加一个输入框。我们可以从Calculator中提取一个TemperatureInput组件。 并且提供一个props属性scale，它的值可能是“c”或“f” const scaleNames = { c: 'Celsius', f: 'Fahrenheit' }; class TemperatureInput extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = {temperature: ''}; } handleChange(e) { this.setState({temperature: e.target.value}); } render() { const temperature = this.state.temperature; const scale = this.props.scale; return ( Enter temperature in {scaleNames[scale]}: ); } } 现在Calculator是这样的,有两个输入，输入其中一个时，另一个不更新。 但我们希望能保持同步。 Try it on CodePen class Calculator extends React.Component { render() { return ( ); } } 首先，我们要写两个函数，摄氏度和华氏度的转换，然后返回： function toCelsius(fahrenheit) { return (fahrenheit - 32) * 5 / 9; } function toFahrenheit(celsius) { return (celsius * 9 / 5) + 32; } 这两个函数都是转换数字的。 我们编写另一个函数，将字符串温度和转换器函数作为参数，并返回一个字符串，然后用它来根据一个input来计算另一个input的值。 当temperature不合法时返回空字符串，返回值四舍五入到小数点后三位： function tryConvert(temperature, convert) { const input = parseFloat(temperature); if (Number.isNaN(input)) { return ''; } const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString(); } 例如，tryConvert('abc',toCelsius）返回一个空字符串，而tryConvert('10.22',toFahrenheit）返回'50.396'. 现在两个TemperatureInput组件都将其输入值保存在自己的state。 但是，我们希望这两个输入是相互同步的。当我们更新摄氏温度的输入值时，华氏温度输入框也能显示转换了的华氏温度，反之亦然。 在React中，可以通过将state移动到最接近的共同祖先共享state，这叫做“提升state”。现在从TemperatureInput中删除本地state，并将其移动到Calculator中。 如果计算器拥有共享state，那两个输入中显示的当前温度数据就是这个共享的state中获得,这个共享state可以作为组件的props传递给组件。 但是props是只读的。 当temperature保存在本地状态时，TemperatureInput可以调用this.setState()来更改它。 但是，现在temperature来自parent的props，无法控制temperature。 但是可以通过接收父容器的onTemperatureChange来改变state,当TemperatureInput更新温度时，调用this.props.onTemperatureChange. 翻译不下去了，好啰嗦。。。直接看最后代码吧 Try it on CodePen class TemperatureInput extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); } handleChange(e) { this.props.onTemperatureChange(e.target.value); } render() { const temperature = this.props.temperature; const scale = this.props.scale; return ( Enter temperature in {scaleNames[scale]}: ); } } class Calculator extends React.Component { constructor(props) { super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = {temperature: '', scale: 'c'}; } handleCelsiusChange(temperature) { this.setState({scale: 'c', temperature}); } handleFahrenheitChange(temperature) { this.setState({scale: 'f', temperature}); } render() { const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( ); } } 看下编辑input时会发生什么： React调用在DOM 上onChange事件处理函数。在上面的例子中，就是TemperatureInput组件中的handleChange方法。 TemperatureInput组件中的handleChange方法用输入的值调用this.props.onTemperatureChange() 根据编辑的输入框调用相应的函数，分别是handleCelsiusChange 和handleFahrenheitChange，更新state state改变后，通知React重新获取render方法的返回，得到最新的UI展示对象。 与原有的render返回对比后，更新必要的真实DOM重新渲染 另一个输入框更新为转换后的温度 提升state需要比双向绑定写更多的代码，但有一个好处是：可以很方便的找bug。因为state都是在某一个组件中，这样定位问题的范围就可以大大缩小。 此外，还可以实现自定义逻辑拒绝或转换用户输入。（比如在onChange事件处理函数中对输入进行校验，校验不通过就不更新state,给出提示。） Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:06:22 "},"React快速开始/React快速开始（十一）组合vs继承.html":{"url":"React快速开始/React快速开始（十一）组合vs继承.html","title":"组合vs继承","keywords":"","body":" Composition vs Inheritance 组合与继承 刚接触React的开发人员通常通过继承来实现代码重用，然而我们建议使用组合而不是继承来重用组件之间的代码。React具有强大的组合模型，可以帮助我们解决这些代码重用的问题，而不需要使用继承。 这篇主要是讲 this.props.children 容器（Containment） 一些组件并不能提前知道他们的children是什么。 比如Sidebar和Dialog组件，他们只表示一个通用的盒子，盒子的内容我们自己定义。 例如下面这样, FancyBorder是一个容器组件，里面展示的内容通过props.children获得 function FancyBorder(props) { return ( {props.children} ); } 我们可以通过JSX嵌套传递chilren给组件 Try it on CodePen function WelcomeDialog() { return ( Welcome Thank you for visiting our spacecraft! ); } JSX标签 内的任何内容都将作为props的children属性值传入FancyBorder组件。 因为FancyBorder在一个内部渲染了{props.children}，所以传递的元素将显示在最终输出中。 有时组件中有多个地方需要显示接收到的props内容，那么你可以这样做： Try it on CodePen function SplitPane(props) { return ( {props.left} {props.right} ); } function App() { return ( } right={ } /> ); } React元素（例如和）都只是对象，因此可以像其他数据一样作为props传递。 特殊化（Specialization） 有时一个组件是另一个组件的“special cases”。 例如，我们可以说WelcomeDialog是Dialog的一个特例。在React中这也可以用组合来实现 Try it on CodePen function Dialog(props) { return ( {props.title} {props.message} ); } function WelcomeDialog() { return ( ); } 组合对于定义为类的组件同样适用： Try it on CodePen function Dialog(props) { return ( {props.title} {props.message} {props.children} ); } class SignUpDialog extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = {login: ''}; } handleChange(e) { this.setState({login: e.target.value}); } handleSignUp() { alert(`Welcome aboard, ${this.state.login}!`); } render() { return ( Sign Me Up! ); } } So What About Inheritance? 在Facebook上，有数千个组件使用React，还没有发现任何用例建议使用组件继承。 props和组合已经提供了以明确和安全的方式自定义组件外观和行为所需的所有灵活性。 请记住，组件可以接受任意props，包括原始值，React元素或函数。 如果要在组件之间重用非UI功能，建议将它提取到单独的JavaScript模块中。 组件可以导入并使用函数，对象或类，而不会扩展它。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 18:05:52 "},"React高级指南/React高级指南（一）深入理解JSX.html":{"url":"React高级指南/React高级指南（一）深入理解JSX.html","title":"深入JSX","keywords":"","body":" JSX In Depth JSX其实就是React.createElement（component，props，... children）函数的语法糖。 JSX代码： Click Me 编译后： React.createElement( MyButton, {color: 'blue', shadowSize: 2}, 'Click Me' ) 如果没有children，也可以用自闭合标签 编译后： React.createElement( 'div', {className: 'sidebar'}, null ) 如果想知道JSX怎么转换成JavaScript，可以在Babel在线编译器上试试 指定React元素类型 JSX标签的首字母就决定了React元素的类型。 首字母大写表示JSX标记指的是React组件。 这些标签会被编译成对命名变量的直接引用，所以如果使用JSX 表达式，Foo必须在可访问范围内。 React必须在可访问范围内 JSX编译后是对React.createElement的调用，所以React库必须始终在JSX代码的访问范围内。 例如，尽管React和CustomButton在JavaScript代码中没有直接用到，但这两个导入都是必需的： import React from 'react'; import CustomButton from './CustomButton'; function WarningButton() { // return React.createElement(CustomButton, {color: 'red'}, null); return ; } 如果是用加载的React，React可以在全局范围内使用，不需要再引入。 对JSX类型使用点符号 还可以使用JSX中的点表示法引用React组件。 如果从一个模块导出很多React组件，例如，MyComponents.DatePicker是一个组件，可以直接在JSX中引用： import React from 'react'; const MyComponents = { DatePicker: function DatePicker(props) { return Imagine a {props.color} datepicker here.; } } function BlueDatePicker() { return ; } 用户定义的组件必须大写开头 当元素类型以小写字母开头时，它表示一个内置的组件，如或，并将一个字符串'div'或'span'传递给React.createElement。 以大写字母开头的类型，如编译为React.createElement（Foo），并与在JavaScript文件中定义或导入的组件对应。 建议用大写字母命名组件，如果你的组件以小写字母开头，在JSX中使用之前请将其分配给大写的变量。 例如，这段代码将无法按预期运行： import React from 'react'; // Wrong! This is a component and should have been capitalized: function hello(props) { // Correct! This use of is legitimate because div is a valid HTML tag: return Hello {props.toWhat}; } function HelloWorld() { // Wrong! React会认为是一个HTML标签，因为不是大写开头: return ; } 下面是正确写法： import React from 'react'; // Correct! This is a component and should be capitalized: function Hello(props) { // Correct! This use of is legitimate because div is a valid HTML tag: return Hello {props.toWhat}; } function HelloWorld() { // Correct! React knows is a component because it's capitalized. return ; } 在运行时确定类型 不能使用通用表达式作为React元素类型。 如果想要使用通用表达式来表示元素类型，请先将其分配给大写的变量。 当你要根据props渲染不同的组件时，会出现这种情况： import React from 'react'; import { PhotoStory, VideoStory } from './stories'; const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // Wrong! JSX type can't be an expression. return ; } 应该先把计算类型的表达式分配给一个大写开头的变量： import React from 'react'; import { PhotoStory, VideoStory } from './stories'; const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // Correct! JSX type can be a capitalized variable. const SpecificStory = components[props.storyType]; return ; } JSX中的Props 在JSX中有几种不同的方式来指定props JavaScript表达式 可以将一个JavaScript表达式传给props，用{}括起来 例如： 对于MyComponent，props.foo的值为表达式1 + 2 + 3 + 4的计算结果:10 在JavaScript中,if语句和for循环不是表达式，所以不能直接在JSX中使用。 可以把逻辑提取出来，结果赋给一个变量，再把这个变量给props 例如： function NumberDescriber(props) { let description; if (props.number % 2 == 0) { description = even; } else { description = odd; } return {props.number} is an {description} number; } 可以在前面的章节中，了解 条件渲染 和 循环 的更多信息 字符串 也可以给props传一个字符串，下面两种方式是等同的 如果要传递没有转义的字符串，下面这两种JSX表达式是等价的 注意：如果这样写： 会被编译成： React.createElement(MyComponent, { message: \"&lt;3\" }); {}中的字符串不会被转义 props默认为“真” 如果没有给一个props传值，它默认为true。 下面这两个JSX表达式是等价的： ES6中，对象 {foo}是 {foo: foo}的简写，而不是 {foo: true}的简写，所以一般不建议使用默认为“真”这种写法（上面第一种写法），容易混淆。但是它确实符合HTML的行为。 参见 ES6 属性定义 spread运算符 现在有一个对象，如果想把对象中的属性分别传给props，而不是把整个对象传给props,可以使用...扩展运算符， 这两个组件是等效的： function App1() { return ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return ; } 在构建通用容器时，扩展属性可能很有用。 但是也可能会传递很多组件不需要的props，所以建议谨慎使用此语法。 JSX中的Children 在有开始标签和结束标签的JSX表达式中，开始和结束标签之间的内容作为一个特殊的props，通过props.children传递。 有几种不同的方法来传递children： 字符串 在开标签和闭标签之间放入字符串文字，访问props.children就会是那个字符串 例如： Hello world! 这样组件中的props.children将只是字符串“Hello world！”，HTML会被转义，所以可以像写HTML一样写JSX This is valid HTML &amp; JSX at the same time. babel会编译为： React.createElement( \"div\", null, \"This is valid HTML & JSX at the same time.\" ); JSX会在行的开始和结尾处移除空格，也会删除空行， 删除与标签相邻的新行; 在字符串文字中间的换行会被压缩成一个空格。下面这些渲染结果都已一样的： Hello World Hello World Hello World Hello World 最后都会编译成： React.createElement( \"div\", null, \"Hello World\" ); JSX元素 可以将多个JSX元素作为Children，这对显示嵌套组件很有用： 也可以像相面这样混合： Here is a list: Item 1 Item 2 一个React组件不能返回多个React元素，但单个JSX表达式可以有多个子元素，因此，如果希望一个组件呈现多个元素，可以将它包含在一个div中。 JavaScript表达式 也可以将任何JavaScript表达式作为Children，并包含在{}中。 例如，这些表达式是等价的： foo {'foo'} 这样可以呈现任意长度的JSX表达式的列表。 例如： function Item(props) { return {props.message}; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( {todos.map((message) => )} ); } JavaScript表达式可以与其他类型的Children混合使用。 这通常用于代替字符串模板： function Hello(props) { return Hello {props.addressee}!; } 函数 插入JSX中的JavaScript表达式计算结果通常是字符串，React元素或内容列表。 但是，props.children可以像其他prop一样传递任何种类的数据，而不仅仅是React知道如何呈现的种类。 例如，如果你有自定义组件，可以将一个回调函数作为props.children： // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i {items}; } function ListOfTenThings() { return ( {(index) => This is item {index} in the list} ); } 这个例子只是为了说明传递给自定义组件的children可以是任何类型，只要组件在呈现之前可以将它转换成React能够理解的东西，上面这种做法并不常见，只是为了拓展你对JSX的理解。 上面的例子可以改写成这样： function Repeat(props) { return {props.children}; } function ListOfTenThings() { let items = []; for (let i = 0; i This is item {i} in the list); } return ( { items} ); } Booleans, Null, and Undefined会被忽略 false，null，undefined和true是有效的children，但它们不会渲染。 下面这些JSX表达式呈现相同： {false} {null} {undefined} {true} 这对于React元素的条件渲染很有用，下面的例子，如果showHeader为true，仅呈现： {showHeader && } 要注意的是： 有一些假值，比如数字0，仍然会被React渲染。 例如，下面的代码将不会按您预期的那样运行，当props.messages为空数组时会渲染出 ‘0’： {props.messages.length && } 要解决这个问题，请确保&&之前的表达式始终为布尔值 {props.messages.length > 0 && } 所以，如果想要一个呈现false，true，null或undefined这样的值中，必须先将其 转换为字符串： My JavaScript variable is {String(myVariable)}. Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 11:38:31 "},"React高级指南/React高级指南（二）使用PropTypes进行类型检测.html":{"url":"React高级指南/React高级指南（二）使用PropTypes进行类型检测.html","title":"使用PropTypes进行类型检测","keywords":"","body":" Typechecking With PropTypes 注意：React.PropTypes不再适用于React v15.5，请改用库prop-types。 类型检测 当应用程序体量越来越大，可以通过类型检测捕获大量错误。对于某些应用程序，可以使用像Flow或者TypeScript这样的JavaScript扩展来对整个应用程序进行类型检查。 但即使不使用它们，React也有一些内置的类型检查功能。 要对一个组件的props进行类型检查，可以给组件添加一个propTypes属性： import PropTypes from 'prop-types'; class Greeting extends React.Component { render() { return ( Hello, {this.props.name} ); } } Greeting.propTypes = { name: PropTypes.string }; 从PropTypes可以导出很多验证器，用于检测接收的数据是否有效。 在上面这个例子中，使用PropTypes.string检测。 props.name的值无效时（这里是非string类型），JavaScript控制台中会显示警告。 由于考虑到性能，仅在开发模式下才会检查propTypes。 PropTypes 以下是PropTypes提供的不同验证器的示例： import PropTypes from 'prop-types'; MyComponent.propTypes = { // 可以声明一个prop是一个特定的JS原始类型。 默认情况下，这些都是可选的。 //比如props上不要求有optionalArray，但如果有，就应该是PropTypes.array类型 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // optionalNode可以是任何可以被渲染的类型，如数字、字符串、元素或者包含这些类型的数组（片段） optionalNode: PropTypes.node, // optionalElement 应该是一个React元素 optionalElement: PropTypes.element, //也可以使用JS的instanceof操作符声明一个prop是一个类的实例， optionalMessage: PropTypes.instanceOf(Message), // 可以将prop限定在一组特定的值内 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 一个对象可以是多种类型中的一种 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 限定为一个特定类型的数组，如数字数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 限定对象属性值是某种特性类型 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape --todo optionalObjectWithShape: PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number }), //可以在上面那些情况后面链式加上isRequired，表示这个prop属性必须提供，如果没有会给出warning requiredFunc: PropTypes.func.isRequired, // requiredAny可以是任意类型，但必须提供 requiredAny: PropTypes.any.isRequired, // 还可以自定义验证器。 如果验证失败，它应该返回一个Error对象。 //不要`console.warn`或throw，因为这在`oneOfType`里不起作用。 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); } }, // 还可以自定义`arrayOf` and `objectOf`的逻辑，默认是数组或对象中的每一项必须是某种类型值。 // 如果验证失败，应该返回一个Error对象。 // 验证器将被数组或对象中的每个key调用,就是每一项都参与验证逻辑 // 验证器的前两个参数是数组或对象本身和当前项的key customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) { if (!/matchme/.test(propValue[key])) { return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); } }) }; 要求组件只有一个child 使用PropTypes.element可以指定只有一个child可以作为props.children传递给组件。 import PropTypes from 'prop-types'; class MyComponent extends React.Component { render() { // This must be exactly one element or it will warn. const children = this.props.children; return ( {children} ); } } MyComponent.propTypes = { children: PropTypes.element.isRequired }; 指定默认props 通过给组件指定默认的props值，这需要给组件添加defaultProps属性 class Greeting extends React.Component { render() { return ( Hello, {this.props.name} ); } } // Specifies the default values for props: Greeting.defaultProps = { name: 'Stranger' }; // Renders \"Hello, Stranger\": ReactDOM.render( , document.getElementById('example') ); defaultProps用于确保当父组件未指定这个prop.name时，this.props.name也有值。 propTypes类型检查在defaultProps解析之后执行，因此defaultProps也会参与类型检测。 翻译总结 这篇主要介绍组件上的两个特殊属性 Greeting.propTypes 和 Greeting.defaultProps 解析顺序是 先Greeting.defaultProps，后Greeting.propTypes，所以如果有类型检测，Greeting.defaultProps 也会参与检测 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 17:59:15 "},"React高级指南/React高级指南（三）Refs与DOM.html":{"url":"React高级指南/React高级指南（三）Refs与DOM.html","title":"Refs与DOM","keywords":"","body":" Refs and the DOM Refs 和 DOM 在典型的React数据流中，props是父组件与它的children交互的唯一方法。 要修改child，需要用新的props重新渲染。 但是，在有些情况下需要在典型数据流之外强制修改child。 要修改的child可以是React组件的一个实例，也可以是一个DOM元素。 对于这两种情况，React提供了一个窗口。 何时使用Refs Refs有一些比较适合的使用场景： 管理焦点，文本选择或媒体播放 触发强制性动画 与第三方DOM库集成 有些可以声明式完成的事情，就要避免使用refs。 例如，不要在Dialog组件上暴露open()和close()方法，然后在父组件中使用this.refs.dialogRef.open()来控制Dialog，而是将一个isOpen属性传递给它，通过改变this.props. isOpen来控制Dialog的打开和关闭。 不要过度使用Refs 你可能更倾向于使用Refs来控制事情的发生，如果是这样的话，建议多花一点时间研究一下state应该在组件树中的那个位置。 可以在 State提升 这篇看下示例 给DOM元素添加Ref React提供一个可以访问任何组件的特殊属性ref，ref属性接受一个回调函数，并且在组件被装载或卸载之后立即执行回调。 当在HTML元素上使用ref属性时，ref回调函数接收底层的DOM元素作为参数。 例如，下面的代码使用引用回调来存储对DOM节点的引用： class CustomTextInput extends React.Component { constructor(props) { super(props); this.focus = this.focus.bind(this); } focus() { // Explicitly focus the text input using the raw DOM API this.textInput.focus(); } render() { //ref的回调函数将DOM元素input的引用存放在一个实例属性中（如，这里的this.textInput） return ( { this.textInput = input; }} /> ); } } 当CustomTextInput组件装载时，React会调用ref的回调，并将DOM元素作为参数；当CustomTextInput组件卸载时，也会调用ref的回调，但，是将null作为回调函数的参数 ref属性的回调函数中给类设置属性来引用DOM元素，是访问DOM元素的常见方法。 首选的方法就是像上面的例子一样在ref回调中设置属性。这里还有一个更简短的写法： ref = {input => this.textInput = input} 给class组件添加Ref 当在自定义的类组件上使用ref属性时，ref回调接收一个已装载的组件的实例作为参数。 例如，如果我们想模拟在CustomTextInput装载后立即被点击的效果： class AutoFocusTextInput extends React.Component { componentDidMount() { this.textInput.focus(); } render() { return ( { this.textInput = input; }} /> ); } } 注意，只有当CustomTextInput组件被声明为类组件的时候，才起作用： class CustomTextInput extends React.Component { // ... } Refs和函数组件 你可能不会在声明为函数的组件上使用ref属性，因为函数组件没有实例： function MyFunctionalComponent() { return ; } class Parent extends React.Component { render() { // This will *not* work! return ( { this.textInput = input; }} /> ); } } 可以在回调中把input打印出来看一下，输出是null。 如果确实需要ref属性，可以把函数组件转换成类组件，就像在需要生命周期方法或状态时转换步骤一样。Converting a Function to a Class 不过我们可以在功能组件内部使用ref，只要是在DOM元素或者类组件上就行: function CustomTextInput(props) { // textInput must be declared here so the ref callback can refer to it let textInput = null; function handleClick() { textInput.focus(); } return ( { textInput = input; }} /> ); } 将DOM的Refs暴露给父组件 在极少数情况下，我们希望在父组件中访问子组件的DOM节点。通常不建议这样做，因为会破坏组件的封装性，但偶尔也可以用于触发焦点或测量子DOM节点的大小或位置。 如果只是想获取组件实例的话，给子组件添加一个ref并不是一个好方法，而且对函数组件也不起作用。 这种情况下，建议给子组件添加一个props属性，将子组件中的DOM节点的ref回调作为子组件的props传递给子组件，子组件再把这个ref回调函数给它的DOM节点的ref属性，如下示例： function CustomTextInput(props) { return ( ); } class Parent extends React.Component { render() { return ( this.inputElement = el} /> ); } } 子组件CustomTextInput有一个props属性inputRef，值是匿名函数el => this.inputElement = el，组件CustomTextInput将这个props.inputRef传给了它的DOM节点input的ref，这样CustomTextInput装载时就会调用匿名函数el => this.inputElement = el，并将input节点的引用传递给Parent组件的this.inputElement。 这样 在父组件中就能访问到子组件内部的组件或DOM节点了，这个子组件（比如这里的CustomTextInput）可以声明为类，也可以声明为函数。 注意，这里prop属性取名为inputRef并没有特树含义，就是一个普通的prop，只是用Ref结尾语义会更好一些。 其实这告诉了我们一个访问函数组件的方法，上面的例子，我们可以把ref={props.inputRef}挪到CustomTextInput最顶层的节点div上。 通过给函数组件添加inputRef这样的prop，可以绕过 只能给DOM元素和类组件添加ref属性的限制。 这种将实际想要引用的节点的ref回调函数从父组件通过prop传递的方式很有用处，这种方式不仅父组件可以访问到子组件中的DOM节点，祖先组件也可以，只要将这个inputRef从祖先组件（想要访问这个DOM节点的组件）从传递下去就好了。 看下面这个例子： function CustomTextInput(props) { return ( ); } function Parent(props) { return ( My input: ); } class Grandparent extends React.Component { render() { return ( this.inputElement = el} /> ); } } 在这里 ref回调函数是在Grandparent中指定的，并作为一个prop(inputRef)传递给CustomTextInput，CustomTextInput又把它传递给了它的DOM节点。最后，Grandparent中的this.inputElement就会指向CustomTextInputDOM节点 旧版API：String Refs 如果你使用过老版本的React，应该知道在React老版本中ref属性是一个字符串，比如\"textInput\"，并通过this.refs.textInput来访问这个节点。我们建议不要再这样使用，因为字符串refs有一些问题，在以后的版本中可能会被废弃。如果你现在正在使用 this.refs.textInput，我们建议你替换为callback函数。 关于字符串refs的一些问题 React需要跟踪当前渲染组件，这样会让React有点慢 当我们想使用回调来渲染时，例如 ref这个对节点的引用就会放置在DataGrid上。 举个例子： class MyComponent extends Component { renderRow = (index) => { //这样给ref一个字符串的话，ref只能在DataTable访问到，在MyComponent中获取不到 return ; // 这样做是可以的，所以还是要用callback ref return this['input-' + index] = input} />; } render() { return } } 使用string refs没有可组合性，但是callback ref可以 举个例子：issues 8734 this._refs = ref}> Hello 可以通过 this._refs.refs['.$.0']来获取Hello 这个例子是从react issues找的，自己写了个组件组合的例子，通过this._refs拿到的是空对象 --todo 注意事项 如果ref的callback是一个内联函数，在更新的时候会被调用两次，第一次传入的参数是null,第二次传入的是DOM元素或组件实例。这是因为每次render都会创建一个函数实例，所以React需要清除旧的引用并设置新的引用。 你可以通过将ref回调定义为类的方法来避免这种情况，但请注意，在大多数情况下，调用两次并没有关系。 我写了个例子试了一下，前面文章说ref回调会在装载和卸载时立即调用，发现原来组件更新时也会调用，我理解应该是每次执行render都会调用，不知道这样理解有没有问题。 看下面这个例子，在关键地方都console.log了 class MyComponent extends React.Component{ render(){ return ; } } class Parent extends React.Component { constructor(){ super() this.state = { value: '' } } componentDidMount(){ console.log('componentDidMount.......') } changeHandler(e){ this.setState({ value: e.target.value }) } render() { console.log('render.......') return ( { console.log('ref callback.....',input) this.textInput = input; }} onChange={this.changeHandler.bind(this)} /> ); } } ReactDOM.render( , document.getElementById('root') ); 在组件装载时，打印结果： render....... ref callback..... MyFunctionalComponent {props: Object,...} componentDidMount....... 在输入框输入时会调用setState()触发更新，打印结果是： render....... ref callback..... null ref callback..... MyFunctionalComponent {props: Object,...} 说明在组件更新时确实调用了两次 翻译总结 这里可以总结一下类组件比函数组件多哪些功能了： state、life cycle hooks、ref 类组件ref callback参数是组件实例， DOM元素ref callback参数是DOM callback ref vs string ref ，string ref将会被废弃 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 17:59:57 "},"React高级指南/React高级指南（四）不受控组件.html":{"url":"React高级指南/React高级指南（四）不受控组件.html","title":"不受控组件","keywords":"","body":"不受控组件 大多数情况下，我们建议使用受控组件来实现表单。 在受控组件中，表单数据由React组件来处理。 替代方案是不受控制的组件，其中表单数据由DOM本身处理。还有一种替代方案就是使用不受控组件，不受控组件的表单数据由DOM本身处理。 编写一个不受控制的组件，就不是为每个可变状态提供事件处理程序了，而是使用ref从DOM获取表单值。 例如，下面的不受控组件，接收一个单一的name: Try it on CodePen class NameForm extends React.Component { constructor(props) { super(props); this.handleSubmit = this.handleSubmit.bind(this); } handleSubmit(event) { alert('A name was submitted: ' + this.input.value); event.preventDefault(); } render() { return ( Name: this.input = input} /> ); } } 由于不受控组件将DOM的真实数据保存在DOM中，在使用不受控组件时，集成React和非React代码更为容易，也可以扫尾减少一点代码量。如果没有这种需求，还是建议使用受控组件，由React来控制form表单。 如果仍然不清楚在某种场景下应该使用受控组件还是不受控组件，这篇关于受控与不受控输入的文章 controlled-vs-uncontrolled-inputs-react 可能对你有帮助。 指定默认值defaultValue 在React渲染生命周期中，form元素上的value属性会覆盖DOM中的值。 使用不受控制的组件时，通常希望React指定初始值，但后续更新后就不再显示初始值。 要处理这种情况，可以指定一个defaultValue属性而不是value属性。 render() { return ( Name: this.input = input} /> ); } 同样，和支持defaultChecked，而和支持defaultValue。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-17 20:09:12 "},"React高级指南/React高级指南（五）性能优化.html":{"url":"React高级指南/React高级指南（五）性能优化.html","title":"性能优化","keywords":"","body":" Optimizing Performance 优化性能 React内部已经最大限度地减少更新UI时DOM操作次数，不需要做太多工作来专门优化性能。React还提供了几种方法可以加快React应用程序。 使用生产版本构建 默认情况下，React包含许多有用的警告，这些警告在开发中非常有用，但是也会让项目更大更慢，所以部署项目到线上时应该使用生产版本。 如果你不确定你的构建过程是否设置正确，可以通过安装Chrome的React Developer Tools进行检查。 如果在生产模式下访问React应用页面，图标背景是深色： 如果是在开发模式下访问React应用页面，图标背景是红色（明明是橙色嘛）： 建议在开发应用程序时使用开发模式，将应用程序部署到线上时的使用生产模式。 那么怎样告诉你的网站使用正确的版本，最有效地配置生产构建过程呢？下面介绍了几种场景下的配置 create-react-app 执行npm run build会在项目的build/目录生成生产版本代码，如果不是在生产环境，执行npm start 引用外部文件 下面引用的直接就是生产环境版本，注意只有 .min.js结尾的才是生产环境稳定版本 Brunch配置 安装插件uglify-js-brunch //If you use npm npm install --save-dev uglify-js-brunch //If you use Yarn yarn add --dev uglify-js-brunch 然后使用brunch build -p构建 Browserify配置 安装几个插件 //If you use npm npm install --save-dev bundle-collapser envify uglify-js uglifyify //If you use Yarn yarn add --dev bundle-collapser envify uglify-js uglifyify 执行时带上这些transforms envify uglifyify bundle-collapser 最后结果都pipe到uglify-js ,read why browserify ./index.js \\ -g [ envify --NODE_ENV production ] \\ -g uglifyify \\ -p bundle-collapser/plugin \\ | uglifyjs --compress --mangle > ./bundle.js Rollup配置 安装插件 //If you use npm npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify //If you use Yarn yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify 再配置文件 plugins: [ // ... require('rollup-plugin-replace')({ 'process.env.NODE_ENV': JSON.stringify('production') }), require('rollup-plugin-commonjs')(), require('rollup-plugin-uglify')(), // ... ] webpack配置 if(env == 'production'){ new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production') } }), new webpack.optimize.UglifyJsPlugin() } 使用Chrome的Performance工具分析组件 在开发模式下，我们可以使用浏览器中的性能工具来显示组件是怎样装载、更新和卸载的。 例如： 你需要在Chrome中执行下面的操作： 加载页面时，在url后加上?react_perf，例如http://localhost:3000/?react_perf 打开Chrome DevTools 性能选项，然后点击录制（Record）。 执行您要配置的操作。 不要记录超过20秒钟，否则Chrome可能挂起。 停止录制 React事件在 User Timing下分组 注意，数字是相对的，在生产模式下组件会有更快的呈现速度。 但这依然可以帮助你找到那些不必要更新却依然被更新的UI，以及UI更新的深度和频率。 目前，支持此功能的浏览器只有Chrome，Edge和IE，但是我们使用标准的 User Timing API ，所以我们希望有更多的浏览器可以支持。 避免不必要的DOM更新 React构建并维护已渲染UI的内部表示信息（JavaScript对象），包括从组件返回的React元素。 这种UI表示信息能够让React避免在不必要的情况下创建DOM节点并访问已有的节点，因为操作DOM比操作JavaScript对象更慢.有时这个React内部表示信息被称为“虚拟DOM”，但它与在React Native上的工作方式相同。 当组件的props或state更改时，React通过将新返回的元素与先前渲染的元素进行比较来决定是否需要更新真实DOM。 当它们不相等时，React将更新真实DOM元素。 在某些情况下，你的组件可以通过重写生命周期函数shouldComponentUpdate来加速渲染，这个函数在重新render之前触发。 此函数默认返回true，使React执行更新： shouldComponentUpdate(nextProps, nextState) { return true; } 如果你知道在某些情况下，你的组件不需要更新，则可以在shouldComponentUpdate中返回false，跳过整个渲染过程，包括在此组件上的render(）和组件下方子组件的渲染。 shouldComponentUpdate 下面是一个组件树，对于每一个节点: SCU表示shouldComponentUpdate返回什么，绿色SCU表示返回true，红色SCU表示返回false 绿色vDOMEq表示虚拟DOM相等，红色vDOMEq表示虚拟DOM不相等 圆圈表示组件是否需要更新真实DOM，绿色表示不需要，红色表示需要。 由于在以C2为根节点的子树上shouldComponentUpdate返回了false，所以React没有去渲染C2，也没有在C4和C5上调用shouldComponentUpdate。 对于C1和C3，shouldComponentUpdate返回true，所以React必须下到叶子节点并检查它们是否需要更新。 对于C6， shouldComponentUpdate返回true，由于渲染的元素与原来的不等同，就需要更新真实DOM。 最后比较有趣的是C8。 React必须渲染这个组件，但由于它返回的React元素等于之前渲染的元素相同，所以不必更新DOM。 注意，React只需要对C6进行DOM更新，这是不可避免的。对于C8，React通过与之前渲染的React元素比较来避免了对DOM进行不必要的更新。对于C2的子树和C7，因为shouldComponentUpdate返回了false,所以不需要比较虚拟DOM，并且不会调用render。 例子 如果只有当 props.color 和 the state.count 变量改变时组件才会更新，你可以使用shouldComponentUpdate来检查： class CounterButton extends React.Component { constructor(props) { super(props); this.state = {count: 1}; } shouldComponentUpdate(nextProps, nextState) { if (this.props.color !== nextProps.color) { return true; } if (this.state.count !== nextState.count) { return true; } return false; } render() { return ( this.setState(state => ({count: state.count + 1}))}> Count: {this.state.count} ); } } 在上面的代码中，shouldComponentUpdate 仅仅比较了props.color 和 the state.count是否改变，如果它们的值没有变化，组件就不会更新。 如果您的组件变得更加复杂，可以使用类似的方式，在props和state的所有字段之间进行“浅比较”，以确定组件是否应该更新。 这种模式很普遍，React提供了一个帮助程序来实现这个逻辑 - 只需要继承自React.PureComponent。 所以可以用下面的代码来实现同样的事情，这种方式更简单： class CounterButton extends React.PureComponent { constructor(props) { super(props); this.state = {count: 1}; } render() { return ( this.setState(state => ({count: state.count + 1}))}> Count: {this.state.count} ); } } 多数情况下，您可以使用React.PureComponent而不需要自己编写通过浅比较不能检测props或state是否发生变化，就不能使用这种方式。 对于复杂的数据结构来说这是一个问题，例如，你想要一个ListOfWords组件来呈现一个逗号分隔的单词列表，其中包含一个父组件WordAdder，我们可以单击一个按钮将单词添加到列表中。 下面的代码将无法正常工作： class ListOfWords extends React.PureComponent { render() { return {this.props.words.join(',')}; } } class WordAdder extends React.Component { constructor(props) { super(props); this.state = { words: ['marklar'] }; this.handleClick = this.handleClick.bind(this); } handleClick() { // This section is bad style and causes a bug const words = this.state.words; words.push('marklar'); this.setState({words: words}); } render() { return ( ); } } 这里的问题是PureComponent会对this.props.words的旧值和新值进行简单的比较（对于引用类型比较的是引用）。 由于调用handleClick方法会让word数组发生变化，所以在ListOfWords中会对比this.props.words的旧值和新值是否相等，但对比结果是相等的，即使数组中的实际值已更改（因为数组引用值没有变化）。 因此即使ListOfWords应该呈现新单词也不会更新。 不可变数据的作用 避免这个问题最简单的方法就是让props 或 state原有的值不变化，返回一个新的对象。 例如在上面的handleClick方法中可以使用concat重写： handleClick() { this.setState(prevState => ({ words: prevState.words.concat(['marklar']) })); } ES6提供了一种数组扩展语法，使这更容易。 如果您使用的是Create React App，则此语法默认可用。 handleClick() { this.setState(prevState => ({ words: [...prevState.words, 'marklar'], })); }; 也可以以类似的方式重写可变对象。 例如，假设有一个colormap对象，我们想编写一个将colormap.right更改为“蓝色”的函数。 我们可以这样写： function updateColorMap(colormap) { colormap.right = 'blue'; } 为了不改变原始对象，我们可以使用Object.assign方法： function updateColorMap(colormap) { return Object.assign({}, colormap, {right: 'blue'}); } 现在updateColorMap返回一个新的对象，而不是改变原来的对象。 Object.assign在ES6中，并且需要一个polyfill。(这是因为很多浏览器没有实现这个方法，可以参见 Object.assign 浏览器兼容性) JavaScript也提供了另一种扩展对象属性的方法，也是使用ES6扩展运算符，这可以返回一个新对象： function updateColorMap(colormap) { return {...colormap, right: 'blue'}; } 如果您使用的是Create React App，默认情况下Object.assign和对象扩展语法都是可以使用的。 使用不可变数据结构 Immutable.js 是解决这个问题的另一种方法。 它通过结构共享提供不变的、持久的集合： 不可变的：集合一旦创建，就不能更改。 持久性：可以从先前的集合和变化中创建新的集合。 创建新集合后，原始集合仍然有效。 结构共享：尽可能的使用与原始集合相同的结构创建新集合，将复制减少到最低限度，提高性能。 不可变性使跟踪变化变得简单，每次更改都会得到一个新对象，所以我们只需要检查对对象的引用是否更改。 例如，在这个常规的JavaScript代码中： const x = { foo: 'bar' }; const y = x; y.foo = 'baz'; x === y; // true 尽管y被改变了，由于它与x是对同一个对象的引用，所以它们的比较返回true。 你可以用immutable.js编写类似的代码： const SomeRecord = Immutable.Record({ foo: null }); const x = new SomeRecord({ foo: 'bar' }); const y = x.set('foo', 'baz'); x === y; // false 在这种情况下，由于在改变x时返回了新的引用，我们可以安全地假设x已经改变。 还有另个库可以帮助我们使用不可变数据： seamless-immutable 和 immutability-helper 不可变数据结构为您提供了跟踪对象变化的便宜方法，这就是我们实现shouldComponentUpdate所需要的。 shouldComponentUpdate + 不可变数据通常可以让React应用得到不错的性能提升。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 21:14:18 "},"React高级指南/React高级指南（六）不使用ES6的React.html":{"url":"React高级指南/React高级指南（六）不使用ES6的React.html","title":"不使用ES6的React","keywords":"","body":" React Without ES6 不使用ES6的React 通常我们会将React组件定义为一个JavaScript类： class Greeting extends React.Component { render() { return Hello, {this.props.name}; } } 如果不使用ES6，也可以使用create-react-class模块： var createReactClass = require('create-react-class'); var Greeting = createReactClass({ render: function() { return Hello, {this.props.name}; } }); ES6类的API与createReactClass()类似，但也有一些不同。 声明 Default Props 对于函数组件和类组件，defaultProps被定义为组件本身的属性： class Greeting extends React.Component { // ... } Greeting.defaultProps = { name: 'Mary' }; 使用createReactClass()，您需要将getDefaultProps()定义为传递对象上的函数： var Greeting = createReactClass({ getDefaultProps: function() { return { name: 'Mary' }; }, // ... }); 设置 Initial State 在ES6类中，您可以在构造函数中设置this.state来定义初始状态： class Counter extends React.Component { constructor(props) { super(props); this.state = {count: props.initialCount}; } // ... } 使用createReactClass()，您必须提供一个返回初始状态的方法getInitialState： var Counter = createReactClass({ getInitialState: function() { return {count: this.props.initialCount}; }, // ... }); 自动绑定this 在声明为ES6类的React组件中，方法遵循与常规ES6类相同的语义，这意味着React不会自动将其绑定到实例。 你必须在构造函数中明确使用.bind（this）： class SayHello extends React.Component { constructor(props) { super(props); this.state = {message: 'Hello!'}; // 这一行很重要!！ this.handleClick = this.handleClick.bind(this); } handleClick() { alert(this.state.message); } render() { // 因为 `this.handleClick` 已经绑定到实例, 我们可以直接使用它作为事件处理程序 return ( Say hello ); } } 使用createReactClass()，就不需要了，因为它绑定了所有方法： var SayHello = createReactClass({ getInitialState: function() { return {message: 'Hello!'}; }, handleClick: function() { alert(this.state.message); }, render: function() { return ( Say hello ); } }); 这意味着使用ES6类会让事件处理程序有很多重复代码，如this.xxx.bind(this)。如果你不喜欢代码中有很多bind，可以借助Babel使用提案中的实验性类属性 属性初始化器 class SayHello extends React.Component { constructor(props) { super(props); this.state = {message: 'Hello!'}; } // 注意: 这个语法是实验性的! // 使用箭头绑定方法: handleClick = () => { alert(this.state.message); } render() { return ( Say hello ); } } 请注意，上面的语法是实验性的，语法可能会改变，或者提案可能不会使其成为语言规范。 有几种安全的做法： 在构造函数中绑定方法 使用箭头函数，例如 onClick = {（e）=> this.handleClick（e）}。 使用createReactClass Mixins 注意，ES6不支持mixin。 因此，当您使用React与ES6类时，不支持mixins。我们还在使用mixins的代码库中发现了许多问题，不建议在新代码中使用它们。本节仅供参考，不要应用于项目中 有时完全不同的组件可能会共享一些常见的功能。 这种情况有时被称为 cross-cutting concerns，为此可以让您可以通过createReactClass使用老的mixins系统来实现。 一个常见的例子是希望每个一段时间更新一次组件，你会很容易想到setInterval()，但有一点很重要：当你不需要时要去取消这个定时功能，以节省内存。 React提供了生命周期方法，让您知道何时创建或销毁组件。我们可以创建一个简单的mixin:用这些方法来提供一个简单的setInterval() 函数，当组件销毁时，这个函数会自动清除。 var SetIntervalMixin = { componentWillMount: function() { this.intervals = []; }, setInterval: function() { this.intervals.push(setInterval.apply(null, arguments)); }, componentWillUnmount: function() { this.intervals.forEach(clearInterval); } }; var createReactClass = require('create-react-class'); var TickTock = createReactClass({ mixins: [SetIntervalMixin], // Use the mixin getInitialState: function() { return {seconds: 0}; }, componentDidMount: function() { this.setInterval(this.tick, 1000); // Call a method on the mixin }, tick: function() { this.setState({seconds: this.state.seconds + 1}); }, render: function() { return ( React has been running for {this.state.seconds} seconds. ); } }); ReactDOM.render( , document.getElementById('example') ); 如果一个组件正在使用多个mixins，并且多个mixin定义了相同的生命周期方法（例如当组件被销毁时，几个mixin都要进行一些清理工作），所有的声明周期方法都会执行。定义在mixins中的方法会按列出的mixins的顺序执行。例如两个mixin都有componentWillMount方法，在组件装载之前会先执行前面的mixin中的componentWillMount 总结 '不使用ES6的React'，应该叫create-react-class的用法 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 21:17:00 "},"React高级指南/React高级指南（七）不使用JSX的React.html":{"url":"React高级指南/React高级指南（七）不使用JSX的React.html","title":"不使用JSX的React","keywords":"","body":" React Without JSX 不使用JSX的React JSX并不是使用React所必须的， 如果不想在构建环境中编译JSX时，可以不使用JSX，这样也很方便。 每个JSX元素都只是调用React.createElement(component，props，... children)的语法糖，所以可以用JSX做的事情也可以用简单的JavaScript来完成。 例如，使用JSX的代码： class Hello extends React.Component { render() { return Hello {this.props.toWhat}; } } ReactDOM.render( , document.getElementById('root') ); 会被编译成： class Hello extends React.Component { render() { return React.createElement('div', null, `Hello ${this.props.toWhat}`); } } ReactDOM.render( React.createElement(Hello, {toWhat: 'World'}, null), document.getElementById('root') ); 注意：Class也会被编译的，这里只展示了JSX编译的结果 如果想知道JSX如何转换为JavaScript，可以使用 在线Babel编译器。 React.createElement(component，props，... children)中的component可以是一个字符串（DOM元素），可以是类组件，也可以是一个无状态的函数组件。 如果不想写React.createElement这么多，可以像这样： const e = React.createElement; ReactDOM.render( e('div', null, 'Hello World'), document.getElementById('root') ); 或者，你可以参考社区项目 react-hyperscript 和 hyperscript-helpers，它们提供更简洁的语法。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 21:19:33 "},"React高级指南/React高级指南（八）Reconciliation.html":{"url":"React高级指南/React高级指南（八）Reconciliation.html","title":"协调（Diff算法）","keywords":"","body":" Reconciliation 协调算法（Diff算法） React提供了一个声明式的API，因此您不必担心每次更新发生了什么变化。 这让编写应用程序变得容易得多，但是在React中这是如何实现的呢？本文介绍了React中的“diff”算法，这种算法让组件更新可预测，同时对于高性能应用程序来说足够快。 动机 当你使用React时，可以思考一下创建一个React元素树的render()函数。在下一次 state 或 props 更新时，render()函数会返回一个不同的React元素树。React需要知道如何有效的更新UI来与当前返回的React元素树匹配一致。 这是一个需要以最小操作次数实现从一棵树转为另一棵树的算法问题，这个问题有一些通用的解决方案。然而标准的diff的算法复杂度为O(n3)，n是树中元素个数。 如果在React中使用这个算法，显示1000个元素需要大约10亿次比较，这无法满足性能要求。 然而React团队基于Web页面的特点做了两个简单的假设，将时间复杂度为降为O(n)： 不同类型的两个元素会产生不同的树，相同类型的元素产生相似的DOM结构 对于同一层次的子节点可以通过key让react知道是否添加、删除或更改 实际上，这些假设对于几乎所有的实际用例都是有效的。 diff算法 当比较两棵树时，React首先比较两个根元素，对于不同类型的根元素，比较行为是不同的。 元素类型不相同 当根元素类型不同时，React会删除旧的树，重新构建新的树。例如从到, 从 到 , 从 到 ，都会重新构建。 当删除旧的树时，老的DOM节点会被销毁，执行组件实例的componentWillUnmount()方法；当构建一个新的树时，新的DOM节点会插入到DOM树中，会执行组件实例的 componentWillMount()和componentDidMount()；任何与旧的树相关的state都会丢失，根组件下的任何子组件都会被销毁。 例如： 这会将老的 销毁，并创建一个新的 。 相同类型的DOM元素 当比较两个相同类型的DOM元素时，React会查看两者的属性，保留相同的底层DOM节点，并且只更新已更改的属性。例如： 通过比较这两个元素，React知道只修改底层DOM节点上的className。 更新样式时，React也知道只更新更改的属性。 例如： 这里React只会修改color，而不会修改fontWeight。 对DOM节点diff处理后，React再对子节点进行递归diff。 相同类型的组件元素 当组件更新时，实例保持不变，从而在渲染过程中保存状态。 React更新底层组件实例的props以匹配新元素，并调用底层实例上的componentWillReceiveProps()和componentWillUpdate()。 接下来，调用render()方法，并且对上一个返回结果和新结果进行递归diff。 在Children上递归 默认情况下，当对DOM节点的子节点进行递归时，React会同时遍历两个子列表. 例如，当在列表的最后添加一个元素时，这两个树之间的转换很简单： first second first second third React会匹配第一个li first 和第二个li first，然后插入第三个li。 但是如果在列表最前面插入一项，性能就会变差。例如： Duke Villanova Connecticut Duke Villanova react会替换掉每一项， Connecticut替换Duke，Duke替换Villanova，然后插入Villanova，而不知道保留Duke和Villanova。这样效率会很低。 Keys 为了解决这个问题，React提供一个属性key。 当children有key时，React使用该key将原始树中的列表与新的树中的列表相匹配。 例如， Duke Villanova Connecticut Duke Villanova 现在React知道key为2014的元素是一个新的元素，key为2015和2016的元素只需要移动一下。 通常指定一个key并不困难,您要显示的元素可能已经具有唯一的ID，因此key可以来自你的数据： {item.name} key必须在兄弟节点中是唯一的，但在全局环境下不要求唯一。 你也可以将数组中的项目索引作为key。 如果项目永远不会重新排序，可以使用这种方法。如果会重新排序，执行会很慢，建议不要使用索引。 权衡 React的这种diff算法基于两个假设，如果这个假设不能满足，性能就会受到影响。 该算法不会尝试匹配不同组件类型的子树。如果两个组件输出很相似但类型不同，应该让它们类型相同。 key应该是稳定的、可预测的、唯一的。不稳定的键（如Math.random()生成的）将导致许多组件实例和DOM节点被不必要地重新创建，这会导致子组件的性能下降和状态丢失。 总结 这篇主要是讲react更新的细节：diff算法。 这篇翻译的不太好，不能完全概括diff算法。可以参考这篇深入浅出React（四）：虚拟DOM Diff算法解析，讲的很详细。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-19 14:28:23 "},"React高级指南/React高级指南（九）Context.html":{"url":"React高级指南/React高级指南（九）Context.html","title":"Context","keywords":"","body":" Context Context 使用React可以轻松地通过React组件跟踪数据流。 当你看到一个组件，就能知道props被传递。 有时候希望通过组件树传递数据，但又不想在每个级别都编写代码传递props。 我们可以使用强大的“context”API直接在React中执行此操作。 为什么不使用Context 绝大多数应用程序不需要使用Context,如果您希望应用程序稳定，请不要使用上下文。 这是一个实验性API，将来的React版本不一定支持。 如果您不熟悉Redux或MobX等状态管理库，请不要使用上下文。 对于许多实际应用，这些库及其与React的绑定库（如react-redux）是管理与许多组件相关联的状态的不错选择。 更可您的正确解决方案更可能是Redux，而不是Context。 如果您不是有经验的React开发人员，请不要使用Context。 通常使用props和state是实现功能的更好的方法。 如果您坚持使用Context，请在小范围内使用Context，尽可能的避免直接使用Context API，以便当API更改时更容易升级。 怎样使用Context 这里有一个组件树： class Button extends React.Component { render() { return ( {this.props.children} ); } } class Message extends React.Component { render() { return ( {this.props.text} Delete ); } } class MessageList extends React.Component { render() { const color = \"purple\"; const children = this.props.messages.map((message) => ); return {children}; } } 在上面这个例子中，在MessageList中设置color,然后手动将color通过props向下传递至Button，穿了了组件树 MessageList > Message > Button。 使用Context，可以自动在组件树中传递： const PropTypes = require('prop-types'); class Button extends React.Component { render() { return ( {this.props.children} ); } } Button.contextTypes = { color: PropTypes.string }; class Message extends React.Component { render() { return ( {this.props.text} Delete ); } } class MessageList extends React.Component { getChildContext() { return {color: \"purple\"}; } render() { const children = this.props.messages.map((message) => ); return {children}; } } MessageList.childContextTypes = { color: PropTypes.string }; 给MessageList（Context提供者）添加childContextTypes属性，并给MessageList实例添加getChildContext方法，React会自动的将context信息（color）向下传递给子树，添加了contextTypes的子组件可以通过this.context获得祖先传递下来的数据，如this.context.color。 如果没有定义contextTypes，this.context是一个空对象 父组件与子组件通信 还可以通过Context构建一个父组件和子组件通信的API。 例如，React Router V4的原理就是这样： import { BrowserRouter as Router, Route, Link } from 'react-router-dom'; const BasicExample = () => ( Home About Topics ); 可以研究一下react-router的实现原理。 在生命周期方法中使用Context 如果给组件定义了contextTypes，则以下 生命周期方法 将接收一个附加参数，即context对象： constructor(props, context) componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componentWillUpdate(nextProps, nextState, nextContext) componentDidUpdate(prevProps, prevState, prevContext) 在无状态函数组件中使用Context 如果给函数组件也定义了contextTypes属性，那在无状态函数组件中也可以使用Context。 下面将Button组件声明为函数： const PropTypes = require('prop-types'); const Button = ({children}, context) => {children} ; Button.contextTypes = {color: PropTypes.string}; 注意函数组件的第一个参数是props，这里使用了对象解构。 更新Context 不要这样做。 React有一个API来更新上下文，但是它基本上被推翻了，你不应该使用它。 当state或props更改时，会调用getChildContext函数。 为了更新Context中的数据，请使用this.setState触发本地状态更新。 这将产生一个新的context，并被children接收。 const PropTypes = require('prop-types'); class MediaQuery extends React.Component { constructor(props) { super(props); this.state = {type:'desktop'}; } getChildContext() { return {type: this.state.type}; } componentDidMount() { const checkMediaQuery = () => { const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile'; if (type !== this.state.type) { this.setState({type}); } }; window.addEventListener('resize', checkMediaQuery); checkMediaQuery(); } render() { return this.props.children; } } MediaQuery.childContextTypes = { type: PropTypes.string }; 问题是，当组件提供的context的值更改时，使用该值的后代的中间父组件在调用shouldComponentUpdate时返回false，就不会更新了，也就完全不能控制组件，所以基本上没有办法可靠地更新context。 这篇博客 怎样安全的使用react context 很好的解释了：为什么这是一个问题，以及如何解决它。 疑问： 如果手动传递props，在这种情况下不是也不能更新么么么？？ Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-20 21:27:11 "},"React高级指南/React高级指南（十）Web Components.html":{"url":"React高级指南/React高级指南（十）Web Components.html","title":"Web组件","keywords":"","body":" Web Components Web Components Web组件 （建议先看下Web Components的介绍）为可重用组件提供了强大的封装，而React是一个JavaScript库，用于构建UI，使DOM与数据保持同步。他们解决的问题不同，但解决目标是互补的。 作为开发人员，您可以在Web Components中自由使用React，或者在React中使用Web Components，或者同时使用两者。 在React中使用Web Components class HelloMessage extends React.Component { render() { return Hello {this.props.name}!; } } 注意： Web组件通常会暴露一个API。 例如，视频Web组件可能会提供play()和pause()函数。 要访问Web组件的API，需要使用ref直接与DOM节点进行交互。 如果使用第三方Web组件，最佳解决方案是编写一个React组件，把Web组件包在里面。 Web组件触发的事件可能无法通过React渲染树正确传播，需要在React组件内部手动添加事件处理程序。 还要注意一点：Web Components使用“class”而不是“className”。 function BrickFlipbox() { return ( front back ); } 在你的Web Components中使用React const proto = Object.create(HTMLElement.prototype, { attachedCallback: { value: function() { const mountPoint = document.createElement('span'); this.createShadowRoot().appendChild(mountPoint); const name = this.getAttribute('name'); const url = 'https://www.google.com/search?q=' + encodeURIComponent(name); ReactDOM.render({name}, mountPoint); } } }); document.registerElement('x-search', {prototype: proto}); PS: 这篇的应用见得比较少。。。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-20 21:54:38 "},"React高级指南/React高级指南（十一）高阶组件.html":{"url":"React高级指南/React高级指南（十一）高阶组件.html","title":"高阶组件","keywords":"","body":" Higher-Order Components 高阶组件 高阶组件（HOC）是React中用于重用组件逻辑的一种高级技术。 HOCs本身并不是React API的一部分，而是React组件组合的一种模式。 具体来说，高阶组件是一个函数，接收一个组件并返回一个新组件。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 就像组件将props转换成UI，高阶组件将一个组件转换成另一个组件。HOC在第三方React库中很常见，例如Redux的 connect 和Relay的 createContainer。 在本文中，我们将讨论为什么高阶组件是有用的，以及如何编写自己的高阶组件。 使用HOC解决不同组件有相似功能的问题 不使用ES6的React 这篇有提到这个：有时完全不同的组件可能会共享一些常见的功能。 这种情况有时被称为 cross-cutting concerns 之前我们建议用mixins解决Cross-Cutting问题，但我们意识到mixins会带来很多问题，可以阅读更多关于为什么我们要弃用mixins，以及如何将你现有的使用到mixins的组件剥离mixins。 戳 Mixins Considered Harmful。 组件是React中代码重用的主要单元。 但是，你会发现某些模式并不适合传统组件。 例如，现在有一个CommentList组件，通过订阅外部数据源来呈现注释列表： class CommentList extends React.Component { constructor() { super(); this.handleChange = this.handleChange.bind(this); this.state = { // \"DataSource\" is some global data source comments: DataSource.getComments() }; } componentDidMount() { // Subscribe to changes DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { // Clean up listener DataSource.removeChangeListener(this.handleChange); } handleChange() { // Update component state whenever the data source changes this.setState({ comments: DataSource.getComments() }); } render() { return ( {this.state.comments.map((comment) => ( ))} ); } } 然后，又写了一个博客组件，也是订阅相同的外部数据源，这样就写了一份模式相同的代码： class BlogPost extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { blogPost: DataSource.getBlogPost(props.id) }; } componentDidMount() { DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { DataSource.removeChangeListener(this.handleChange); } handleChange() { this.setState({ blogPost: DataSource.getBlogPost(this.props.id) }); } render() { return ; } } CommentList与BlogPost是两个不同的组件 ： 它们在DataSource上调用不同的方法，并且它们呈现不同的输出。 但是他们的实现大部分是相同的： 在componentDidMount中（装载后），添加一个更改监听器到DataSource。 在侦听器中，只要数据源发生变化，就调用setState。 在componentWillUnmount中（卸载时），删除侦听器。 可以想象，在一个大型应用程序中，同样的订阅DataSource和调用setState的模式会出现很多次。 我们希望能把这个逻辑抽象出来在一个地方定义，很多组件都能分享这个逻辑，这就是高阶组件最强大之处。 我们可以编写一个函数来创建订阅DataSource的组件，如CommentList和BlogPost。这里我们将这个函数命名为withSubscription，withSubscription接收一个子组件作为参数，这个组件将订阅的数据作为props。 const CommentListWithSubscription = withSubscription( CommentList, (DataSource) => DataSource.getComments() ); const BlogPostWithSubscription = withSubscription( BlogPost, (DataSource, props) => DataSource.getBlogPost(props.id) ); 第一个参数是被包装的组件，第二个参数是一个函数，接收DataSource和当前props,返回我们想要的数据。 当组件CommentListWithSubscription和BlogPostWithSubscription被渲染时，CommentList和BlogPost将被传递一个prop（从DataSource获取的最新的数据）： // This function takes a component... function withSubscription(WrappedComponent, selectData) { // ...and returns another component... return class extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { data: selectData(DataSource, props) }; } componentDidMount() { // ... that takes care of the subscription... DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { DataSource.removeChangeListener(this.handleChange); } handleChange() { this.setState({ data: selectData(DataSource, this.props) }); } render() { // ... and renders the wrapped component with the fresh data! // Notice that we pass through any additional props return ; } }; } 注意，HOC不会修改传入的组件，也不会使用继承来复制组件的行为。 相反，HOC通过将原始组件包装在容器组件中来组合。 HOC是具有零副作用的纯函数。 被包装的组件接收容器组件的所有props，还有一个新的prop（data）。HOC并不关心怎么使用、为什么需要data;被包装组件也不需要关心data从哪里来。 因为withSubscription是一个正常的函数，所以您可以添加任意数量的参数。例如，您可能希望prop.data的名称可配置，从而进一步将HOC与包装组件隔离。 或者您可以接收一个参数来配置shouldComponentUpdate或配置数据源。 这些都是可能的，因为HOC可以完全控制组件的定义。 与组件一样，withSubscription函数与被包装组件之间的联系完全是基于props的。 这样可以方便地将一个HOC转换为不同的HOC，只要它们为被包装组件提供相同的props。 例如，更改获取数据的库。 不要改变原始组件，请使用组合 不要再HOC内修改组件的原型 function logProps(InputComponent) { //这里的写法有问题吧？不是应该直接给componentWillReceiveProps赋一个函数么，这样会报错的 InputComponent.prototype.componentWillReceiveProps(nextProps) { console.log('Current props: ', this.props); console.log('Next props: ', nextProps); } // 返回原始组件是为了告诉你这个组件已经被改变了 return InputComponent; } // EnhancedComponent将会在接收到props时console.log const EnhancedComponent = logProps(InputComponent); 这样就会有几个问题： 输入组件不能重用，因为被EnhancedComponent修改了 更重要的是，如果将另一个HOC应用于EnhancedComponent，componentWillReceiveProps会被改变，第一个HOC的功能会被覆盖。 ??没明白 这个HOC也不适用于没有生命周期方法的函数组件。 会改变输入的HOC是一个有缺漏的抽象，使用者必须知道它的内部实现从而避免与其他的HOC产生冲突。 因而，HOC应该使用组合，将输入组件包装在容器组件中： function logProps(WrappedComponent) { return class extends React.Component { componentWillReceiveProps(nextProps) { console.log('Current props: ', this.props); console.log('Next props: ', nextProps); } render() { // Wraps the input component in a container, without mutating it. Good! return ; } } } 这个HOC与上面的版本有着相同的功能，同时避免了冲突的可能性，并同时适用于类组件和函数组件。 而且因为它是一个纯函数，它可以与其他HOC，甚至与它本身组合。 HOC与容器组件模式很相似，容器组件是分离处理逻辑的一种策略。 容器负责处理诸如订阅和state这样的，并将props传递给负责诸如渲染UI之类的组件。 HOC使用容器作为其实现的一部分。 你可以认为HOC是一个参数化容器组件。 约定：HOC传递它本身不关心的props给被包裹组件 从HOC中返回的组件应该与被包装组件具有相似的界面，因而HOC应该传递它本身不关心的props给被包裹组件（因为被包裹组件关心啊）。大多数HOC包含一个如下所示的渲染方法： render() { //将HOC需要的但不需要传递给被包装组件的props剔出来 const { extraProp, ...passThroughProps } = this.props; // 将props注入被包裹组件,通常是状态值或实例方法。 const injectedProp = someStateOrInstanceMethod; // 将 props 传递给被包裹组件 return ( ); } 这个惯例有助于确保HOC尽可能灵活和可重用。 约定：将组合最大化 并不是所有的HOC都一样,有时他们只接受一个参数，即被包装的组件： const NavbarWithRouter = withRouter(Navbar); 通常，HOC会接收其他参数。 下面是Relay中的一个例子，用config对象来指定组件的数据依赖关系： const CommentWithRelay = Relay.createContainer(Comment, config); HOCs最常见的形式是像这样的： // React Redux's `connect` const ConnectedComment = connect(commentSelector, commentActions)(Comment); 拆分一下看的更清楚： // connect is a function that returns another function const enhance = connect(commentListSelector, commentListActions); // The returned function is an HOC, which returns a component that is connected to the Redux store const ConnectedComment = enhance(CommentList); 换句话说，connect是一个高阶函数，返回一个高阶组件！ 这种调用方式看起来很混乱或者说不必要，但它有一个有用的特点：HOC只有一个参数。connect函数返回的HOC具有Component => Component的特点，输出类型与其输入类型相同的函数很容易组合在一起。 // 不是这样做... const EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent)) // 你可以使用组合工具函数compose // compose(f, g, h) 与 (...args) => f(g(h(...args)))相同 const enhance = compose( // 这些都是单参数HOC connect(commentSelector), withRouter ) const EnhancedComponent = enhance(WrappedComponent) 这种特点还允许connect和其他增强型HOC用作装饰器（一个实验性JavaScript提案） 很多第三方库都会提供compose工具函数，如lodash（lodash.flowRight）、Redux 和 Ramda. 约定：为方便调试，将Display Name包含其中 由HOC创建的容器组件与任何其他组件一样会在React Developer Tools中显示。 为方便调试，给HOC返回的组件定义一个显示名称。 最常见的方法是包装被包装组件的显示名称。如果你的高阶组件名为withSubscription，并且被包装组件的显示名称为CommentList，那HOC返回组件请使用显示名称：WithSubscription（CommentList）： function withSubscription(WrappedComponent) { class WithSubscription extends React.Component {/* ... */} WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`; return WithSubscription; } function getDisplayName(WrappedComponent) { return WrappedComponent.displayName || WrappedComponent.name || 'Component'; } 注意 关于高阶组件有一些需要注意的地方。 不要在render方法中使用高阶组件 React的Diff算法（称为reconciliation）使用组件标识来确定是否需要更新、卸载或装载。如果从render方法中返回的组件与先前的render返回的组件相同（===），React会递归的对子组件diff，如果子组件类型不相同会被完全卸载。 我们通常不需要考虑这个，但是对于HOC来说很重要，因为这意味着我们不能将HOC应用于render方法中的组件： render() { // 每次render都会创建新的EnhancedComponent，每次的结果都是不相等的（组件标识不同） // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // 因此每次都会先卸载老的，再装载新的 return ; } 这不仅会产生性能问题，重新安装组件会导致该组件及其所有子项的状态丢失。所以，我们应该在组件定义之外应用HOC，这样HOC生成的组件只能创建一次，在渲染过程中只会有这一个组件标识。 在一些比较少见的情况下，需要动态应用HOC，这时你可以在组件的生命周期方法或其构造函数中操作。 静态方法必须复制 有时在React组件上定义一个静态方法很有用处。 例如，Relay暴露一个静态方法getFragment用来构建GraphQL片段。 当将HOC应用于组件时，原始组件被容器组件包装。那HOC返回的新组件就没有原始组件的任何静态方法。 // Define a static method WrappedComponent.staticMethod = function() {/*...*/} // Now apply an HOC const EnhancedComponent = enhance(WrappedComponent); // The enhanced component has no static method typeof EnhancedComponent.staticMethod === 'undefined' // true 为了解决这个问题，我们可以在返回之前将静态方法复制到容器组件上： function enhance(WrappedComponent) { class Enhance extends React.Component {/*...*/} // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance; } 但是，这需要我们准确地知道需要复制哪些方法。 但是我们可以使用hoist-non-react-statics来自动复制所有非React静态方法： import hoistNonReactStatic from 'hoist-non-react-statics'; function enhance(WrappedComponent) { class Enhance extends React.Component {/*...*/} hoistNonReactStatic(Enhance, WrappedComponent); return Enhance; } // Instead of... MyComponent.someFunction = someFunction; export default MyComponent; // ...export the method separately... export { someFunction }; // ...and in the consuming module, import both import MyComponent, { someFunction } from './MyComponent.js'; 另一个可能的解决方案是将组件的静态方法与组件本身分开导出。 不能传递Refs 高阶组件一般会将所有的props传递给被包装的组件，但是不可能传递ref。 ref和key一样，并不是真正的prop,是由React特别处理的。 如果想要给一个元素添加ref，该元素的组件是HOC返回的组件，则ref引用的是最外层的容器组件的实例，而不是被包装组件的实例。 如果你遇到了这个问题，应该想想怎么避免使用ref，如前面介绍过的 Refs与DOM，可以使用props传递ref回调。例如： function Field({ inputRef, ...rest }) { return ; } // Wrap Field in a higher-order component const EnhancedField = enhance(Field); // Inside a class component's render method... { // This callback gets passed through as a regular prop this.inputEl = inputEl }} /> // Now you can call imperative methods this.inputEl.focus(); 这并不是一个完美的解决方案。 我们希望ref仍然是React本身需要关注的，而不是要求您手动处理它们。 我们正在探索解决这个问题的方法，以便使用HOC时不需要关注这些。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-23 15:24:22 "},"React高级指南/React高级指南（十二）React与其他库整合.html":{"url":"React高级指南/React高级指南（十二）React与其他库整合.html","title":"React与其他库整合","keywords":"","body":" Integrating with Other Libraries 与其他库集成 React可用于任何Web应用程序，可以嵌入到其他应用程序中，其他应用程序也可以嵌入到React中。 本篇将介绍一些常见的用例，主要是React与 jQuery和 Backbone的集成，这里介绍的思路也可用于与其他库的集成。 与DOM操作插件集成 React之外的库对DOM的更改，React本身并不知道，它仅基于自己的内部表示来确定是否更新，如果相同的DOM节点被另一个库操作，则React会很迷惑。 但这并不意味着将React与操作DOM的其他方式相结合是不可能的事情，，你只需要关注它们各自在做什么。 避免冲突的最简单方法是阻止React组件更新，我们可以通过渲染React无法更新的元素来实现，如空的。 如何解决问题 我们来编写一个通用的jQuery插件的包装器： class SomePlugin extends React.Component { componentDidMount() { this.$el = $(this.el); this.$el.somePlugin(); } componentWillUnmount() { this.$el.somePlugin('destroy'); } render() { return this.el = el} />; } } 在根DOM元素上添加ref属性，获取DOM节点的引用。 在componentDidMount中，把它传递给jQuery插件。 为了防止React在安装后更新DOM，我们从render()方法返回一个空的。 元素没有属性或子元素，所以React不会更新它，这样jQuery插件可以自由地管理DOM的一部分。 注意，我们同时定义了componentDidMount和componentWillUnmount 生命周期钩子。 许多jQuery插件会将事件侦听器添加到DOM，因此在componentWillUnmount中从DOM上去除监听器很重要。 如果插件没有提供清理方法，您可能需要提供自己的方法，记住删除任何注册事件侦听器，防止内存泄漏。 与jQuery选择插件集成 注意：这里只是向您介绍这种可能性，并不意味着它是React应用程序的最佳方法。我们鼓励您可以使用React组件。React组件在React应用程序中更容易重用，并且通常可以更好地控制其行为和外观。 下面介绍一个更具体的例子：为 jQuery插件Chosen写一个最小的包装器，它增加了的输入。 Try it on CodePen class Chosen extends React.Component { componentDidMount() { this.$el = $(this.el); this.$el.chosen(); this.handleChange = this.handleChange.bind(this); this.$el.on('change', this.handleChange); } componentDidUpdate(prevProps) { if (prevProps.children !== this.props.children) { this.$el.trigger(\"chosen:updated\"); } } componentWillUnmount() { this.$el.off('change', this.handleChange); this.$el.chosen('destroy'); } handleChange(e) { this.props.onChange(e.target.value); } render() { return ( this.el = el}> {this.props.children} ); } } function Example() { return ( console.log(value)}> vanilla chocolate strawberry ); } ReactDOM.render( , document.getElementById('root') ); 与其他UI库集成 因为 ReactDOM.render() 比较灵活，React可以嵌入到其他应用程序中。 虽然React在启动时通常是将单个根React组件加载到DOM中，但也可以为UI的独立模块（可以小到一个按钮，大到一个应用程序）调用ReactDOM.render()多次。 用React替换基于字符串的渲染 在旧版Web应用程序中的常见模式是将DOM块描述为字符串，并将其插入到DOM中，如：$ el.html(htmlString)。 在这些地方可以引入React，只需将基于字符串的渲染重写为React组件。 所以下面的jQuery实现： $('#container').html('Say Hello'); $('#btn').click(function() { alert('Hello!'); }); 可以用 React 组件重写成： function Button() { return Say Hello; } ReactDOM.render( , document.getElementById('container'), function() { $('#btn').click(function() { alert('Hello!'); }); } ); 这里将更多的逻辑转移到组件中。例如，在组件中，最好不要依赖于ID，因为相同的组件会被渲染多次。 我们可以使用 React事件系统，直接在React 元素上注册点击处理程序： Try it on CodePen function Button(props) { return Say Hello; } function HelloButton() { function handleClick() { alert('Hello!'); } return ; } ReactDOM.render( , document.getElementById('container') ); 我们可以编写很多这样的组件，并使用ReactDOM.render()将它们渲染到不同的DOM容器。 当您将更多的应用转换为React时，我们可以将它们组合成较大的组件，并将部分ReactDOM.render()调用提升到更高的层次。 在Backbone中嵌入React Backbone views通常使用HTML字符串或字符串生成模板函数来为其DOM元素创建内容。 这个过程也可以通过渲染一个React组件来代替。 下面我们来创建一个Backbone视图ParagraphView，它将覆盖Backbone的render()函数，将React 组件呈现到由Backbone(this.el)提供的DOM元素中。 这里也是使用 ReactDOM.render()： Try it on CodePen function Paragraph(props) { return {props.text}; } const ParagraphView = Backbone.View.extend({ render() { const text = this.model.get('text'); ReactDOM.render(, this.el); return this; }, remove() { ReactDOM.unmountComponentAtNode(this.el); Backbone.View.prototype.remove.call(this); } }); 有一点很重要：为了在被删除时，React能注销与组件树相关联的事件处理程序和其他资源，在remove方法中我们调用ReactDOM.unmountComponentAtNode()。 当一个组件从React树中删除时，清理将自动执行，但是由于我们是手动删除整个树，所以我们必须调用该方法。 与Model层集成 虽然通常建议使用单向数据流，如React状态，Flux或Redux，但React组件也可以使用来自其他框架和库的模型层。 在React组件中使用Backbone Model 在React组件使用Backbone模型和集合的最简单方法是监听各种更改事件并手动强制更新。 负责渲染模型的组件监听“change”事件，而负责呈现集合的组件监听“add”和“remove”事件。 在这两种情况下，调用 this.forceUpdate() 来重新渲染具有新数据的组件。 在下面的示例中，List组件呈现了一个Backbone集合。 Try it on CodePen class Item extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); } handleChange() { this.forceUpdate(); } componentDidMount() { this.props.model.on('change', this.handleChange); } componentWillUnmount() { this.props.model.off('change', this.handleChange); } render() { return {this.props.model.get('text')}; } } class List extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); } handleChange() { this.forceUpdate(); } componentDidMount() { this.props.collection.on('add', 'remove', this.handleChange); } componentWillUnmount() { this.props.collection.off('add', 'remove', this.handleChange); } render() { return ( {this.props.collection.map(model => ( ))} ); } } 从Backbone Model获取数据 上述方法需要您的React组件了解Backbone模型和集合。 如果您以后计划迁移到另一个数据管理方案，您可能希望尽可能将这部分代码集中起来。 这里有一个解决方案：将model的属性作为普通数据无论它何时更改，并将这段逻辑放在一个单独的位置。下面是一个高阶组件，将Backbone model的所有属性提取到state，并将这个数据传递到被包装组件。 function connectToBackboneModel(WrappedComponent) { return class BackboneComponent extends React.Component { constructor(props) { super(props); this.state = Object.assign({}, props.model.attributes); this.handleChange = this.handleChange.bind(this); } componentDidMount() { this.props.model.on('change', this.handleChange); } componentWillReceiveProps(nextProps) { this.setState(Object.assign({}, nextProps.model.attributes)); if (nextProps.model !== this.props.model) { this.props.model.off('change', this.handleChange); nextProps.model.on('change', this.handleChange); } } componentWillUnmount() { this.props.model.off('change', this.handleChange); } handleChange(model) { this.setState(model.changedAttributes()); } render() { const propsExceptModel = Object.assign({}, this.props); delete propsExceptModel.model; return ; } } } 这样就只有高阶组件需要知道Backbone model内部属性，应用程序中的大多数组件可以与Backbone解耦。 在上面的例子中，我们将Backbone模型的attributes设置成初始状态，并订阅change事件（卸载时取消订阅），当model变化时，使用模型的当前属性更新状态。 如果prop.model本身发生变化，取消订阅旧model，并订阅新model。 为了演示如何使用，我们将React组件NameInput 与Backbone model 连接，并在每次输入更改时更新其firstName属性： Try it on CodePen function NameInput(props) { return ( My name is {props.firstName}. ); } const BackboneNameInput = connectToBackboneModel(NameInput); function Example(props) { function handleChange(e) { model.set('firstName', e.target.value); } return ( ); } const model = new Backbone.Model({ firstName: 'Frodo' }); ReactDOM.render( , document.getElementById('root') ); 这种技术并不限于Backbone，我们可以将React与任何模型库一起使用，通过在生命周期函数中订阅其他model库的model更新，并将model数据复制到React的本地state中。 Copyright © chang20159.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-23 15:24:51 "}}